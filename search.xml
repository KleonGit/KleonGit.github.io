<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>机器学习系统 0-0 - 总览</title>
    <url>/ai/ml-system/0-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>机器学习<a href="#refer-1"><sup>1</sup></a>模型对应一类用于从数据中提取模式与特征的人工智能子领域算法。机器学习系统用于更便捷地、更高效地、更自动化地构建机器学习模型，与数据分析系统整合。</p>
<a id="more"></a>
<p>机器学习是数据分析的延展，得益于算法改进（Algorithm)，数据快速增加（Big Data），算力提升（Computing Power），发掘了依赖数据统计理论的业务价值，深度学习模型被大规模应用。</p>
<p>随之而来的，是对快捷便利地构建部署模型的需求，从实验室的原型验证逐步过渡到成熟的大规模机器学习系统。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/ml-system.svg" alt="机器学习系统整体架构"></p>
<p>机器学习系统根据构建阶段可以分为：</p>
<ul>
<li><strong>数据管理</strong></li>
</ul>
<p>机器学习的核心是数据，这些数据通常来自业务系统的数据仓库，通过ETL<a href="#refer-2"><sup>2</sup></a>系统清洗提取后组织成统一的结构化数据。</p>
<p>数据管理子系统用来管理用户导入的结构化数据，称为数据集（Dataset）。通常数据管理子系统提供数据标注功能，由数据工程师或者众包人员标注。</p>
<ul>
<li><strong>模型开发</strong></li>
</ul>
<p>模型的开发与调试需要算法工程师参与，通常使用Python脚本或Jupyter Notebook。常用框架有Tensorflow<a href="#refer-3"><sup>3</sup></a> / PyTorch<a href="#refer-4"><sup>4</sup></a>。开发人员更注重IDE的便捷性，而小微开发者对算力价格更敏感。</p>
<ul>
<li><strong>模型训练</strong></li>
</ul>
<p>模型调试完成后需要大规模训练，通常会调整超参同时启动多个训练任务，这需要大量的算力，通常需要使用分布式训练系统。常用框架有PS（Parameter Server） / All Reduce / Horovod。同时，训练任务的实时参数需要及时(比如通过Tensorboard)反馈给算法工程师，以便调整训练参数。</p>
<ul>
<li><strong>模型部署</strong></li>
</ul>
<p>模型训练完成后，挑选精度/计算量符合业务需求的模型优化部署。模型部署系统需要支持多种标准模型，并且提供后端服务直接调用的接口，注重高吞吐、低延时。常用框架有Tensorflow Serving / TorchServe / Neuropod。在模型部署前，可以有针对地优化模型，以达到提高计算效率，降低推理延迟，节约计算成本等目的。</p>
<p>模型开发人员在首次开发新模型的过程中，需要手动完成模型的训练和部署。之后可以构建自动化训练部署的流水线（蓝色循环），定期或按特定条件触发。</p>
<p>我的经历是从后端硬件加速器入手，逐步扩展到后端硬件软件栈，模型推理优化，到机器学习系统的架构与产品。从下一节开始，我会逐一展开讨论。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="noopener">机器学习</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://zh.wikipedia.org/wiki/ETL" target="_blank" rel="noopener">ETL</a></li>
<li>[3] <span id="refer-3"></span> <a href="https://www.tensorflow.org/" target="_blank" rel="noopener">Tensorflow</a></li>
<li>[4] <span id="refer-4"></span> <a href="https://pytorch.org/" target="_blank" rel="noopener">PyTorch</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 数组</title>
    <url>/cs/algo/array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数组是最基础的数据结构之一，存储线性数据，内存结构连续。</p>
<a id="more"></a>
<p>数组是Go的内置类型，分为静态数组和动态切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Append</span></span><br><span class="line">array = <span class="built_in">append</span>(array, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// Prepend</span></span><br><span class="line">array = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;, array...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">struct</span> Node &#123;</span><br><span class="line">    Value <span class="keyword">int</span></span><br><span class="line">    Next  *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="多个有序数组的第k小数"><a href="#多个有序数组的第k小数" class="headerlink" title="多个有序数组的第k小数"></a>多个有序数组的第k小数</h2><p><img src="https://img.shields.io/badge/leetcode-4-blue.svg" alt> <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个正序数组的中位数</a></p>
<ul>
<li>暴力法: 归并排序后取中位数</li>
<li>指针法：只计中位数</li>
<li>通用寻找第k小数方法<ul>
<li>二分法比较排除较小数组的前k/2个元素</li>
<li>递归查找(k - k/2)/2个元素</li>
</ul>
</li>
</ul>
<h2 id="二分法-升序数组搜索插入位置"><a href="#二分法-升序数组搜索插入位置" class="headerlink" title="二分法-升序数组搜索插入位置"></a>二分法-升序数组搜索插入位置</h2><p><img src="https://img.shields.io/badge/leetcode-35-blue.svg" alt> <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">搜索插入位置</a></p>
<ul>
<li>暴力法，直接搜索，时间复杂度O(n)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> n &gt;= target &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分法，时间复杂度O(logn)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        middle := (right + left) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &gt; target &#123;</span><br><span class="line">            right = middle - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[middle] &lt; target &#123;</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针法-数组原地移除元素"><a href="#双指针法-数组原地移除元素" class="headerlink" title="双指针法-数组原地移除元素"></a>双指针法-数组原地移除元素</h2><p><img src="https://img.shields.io/badge/leetcode-27-blue.svg" alt> <a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">移除元素</a></p>
<ul>
<li>暴力法，查到一个挪一个，时间复杂度O(n<sup>2</sup>)，空间复杂度O(1)</li>
<li>快慢指针法，时间复杂度O(n)，空间复杂度O(1)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    slow := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; <span class="built_in">len</span>(nums); fast++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val &#123;</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口-长度最小的连续子数组"><a href="#滑动窗口-长度最小的连续子数组" class="headerlink" title="滑动窗口-长度最小的连续子数组"></a>滑动窗口-长度最小的连续子数组</h2><p><img src="https://img.shields.io/badge/leetcode-209-blue.svg" alt> <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">长度最小的子数组</a></p>
<ul>
<li>暴力法，两层循环，记下最小长度，时间复杂度O(n<sup>2</sup>)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    min := <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(nums) - i; j++ &#123;</span><br><span class="line">            sum += nums[i + j]</span><br><span class="line">            <span class="keyword">if</span> sum &gt;= target &amp;&amp; min &gt; j + <span class="number">1</span> &#123;</span><br><span class="line">                    min = j + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> min == <span class="built_in">len</span>(nums) + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>滑动窗口，右指针不断右移，当不满足条件时，左指针右移直到满足条件</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="keyword">int</span>, nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l := <span class="number">0</span></span><br><span class="line">    sum, min := <span class="number">0</span>, <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="built_in">len</span>(nums); r++ &#123;</span><br><span class="line">        sum += nums[r]</span><br><span class="line">        <span class="keyword">for</span> sum &gt;= target &#123;</span><br><span class="line">            <span class="keyword">if</span> min &gt; r - l + <span class="number">1</span> &#123;</span><br><span class="line">                min = r - l + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[l]</span><br><span class="line">            l++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> min == <span class="built_in">len</span>(nums) + <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过程模拟-螺旋矩阵"><a href="#过程模拟-螺旋矩阵" class="headerlink" title="过程模拟-螺旋矩阵"></a>过程模拟-螺旋矩阵</h2><p><img src="https://img.shields.io/badge/leetcode-59-blue.svg" alt> <a href="https://leetcode-cn.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">螺旋矩阵II</a></p>
<ul>
<li>直接过程模拟，可用递归或迭代方式模拟每圈</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drawCircle</span><span class="params">(n <span class="keyword">int</span>, x <span class="keyword">int</span>, y <span class="keyword">int</span>, length <span class="keyword">int</span>, count <span class="keyword">int</span>, m [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        m[y][x] = count</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        count++</span><br><span class="line">        m[y][x + i] = count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">        count++</span><br><span class="line">        m[y + i][x + length] = count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := length; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        count++</span><br><span class="line">        m[y + length][x + i] = count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := length; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        count++</span><br><span class="line">        m[y + i][x] = count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    drawCircle(n, x + <span class="number">1</span>, y + <span class="number">1</span>, length - <span class="number">2</span>, count, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        m[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    drawCircle(n, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, m)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针法-平方数之和"><a href="#双指针法-平方数之和" class="headerlink" title="双指针法-平方数之和"></a>双指针法-平方数之和</h2><p><img src="https://img.shields.io/badge/leetcode-633-blue.svg" alt> <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">平方数之和</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judgeSquareSum</span><span class="params">(c <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(c)))</span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        sum := left*left + right*right</span><br><span class="line">        <span class="keyword">if</span> sum == c &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; c &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分法-搜索旋转排序数组"><a href="#二分法-搜索旋转排序数组" class="headerlink" title="二分法-搜索旋转排序数组"></a>二分法-搜索旋转排序数组</h2><p><img src="https://img.shields.io/badge/leetcode-33-blue.svg" alt> <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></p>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 动态规划法</title>
    <url>/cs/algo/dynamic-programming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>动态规划用于就解决包含重叠子问题的问题，其中每一个子问题的状态都是由上一个状态推导出来的。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>动态规划的一般步骤：</p>
<ul>
<li>确定dp数组和其下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ul>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p><img src="https://img.shields.io/badge/leetcode-509-blue.svg" alt> <a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">斐波那契数</a></p>
<ul>
<li>动规，dp数组代表第i个数，和题目直接对应</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><img src="https://img.shields.io/badge/leetcode-70-blue.svg" alt> <a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></p>
<ul>
<li>动规，dp表示到第i级台阶可能的方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p><img src="https://img.shields.io/badge/leetcode-746-blue.svg" alt> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">使用最小花费爬楼梯</a></p>
<ul>
<li>动规，dp表示到第i级台阶可能的方法，最后一步没有花费，取最小值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cost) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(cost))</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(cost); i++ &#123;</span><br><span class="line">        dp[i] = min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dp[<span class="built_in">len</span>(cost) - <span class="number">1</span>], dp[<span class="built_in">len</span>(cost) - <span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p><img src="https://img.shields.io/badge/leetcode-62-blue.svg" alt> <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></p>
<ul>
<li>动规，dp表示到第i,j可能的路径</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="keyword">range</span> dp[<span class="number">0</span>] &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h2><p><img src="https://img.shields.io/badge/leetcode-63-blue.svg" alt> <a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径 II</a></p>
<ul>
<li>动规，dp表示到第i,j可能的路径，加入障碍物后，所以障碍物位置的路径变为0</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    n := <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++ &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++ &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p><img src="https://img.shields.io/badge/leetcode-343-blue.svg" alt> <a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">整数拆分</a></p>
<ul>
<li>动规，dp表示i的最大面积，对于每个拆分的数i，从1开始遍历j到i-1，最大面积是 (i - j) <em> j 和 i - j 的最大面积 </em> j</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++ &#123;</span><br><span class="line">            dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p><img src="https://img.shields.io/badge/leetcode-96-blue.svg" alt> <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></p>
<ul>
<li>dp为节点数为i的二叉树数量，等于所有j-1和i-j的数量组合累加（相加==i-1，去除了根节点），dp[0]为空节点，也可以算作一种</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i; j++ &#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="青蛙过河"><a href="#青蛙过河" class="headerlink" title="青蛙过河"></a>青蛙过河</h2><p><img src="https://img.shields.io/badge/leetcode-403-blue.svg" alt> <a href="https://leetcode-cn.com/problems/frog-jump/" target="_blank" rel="noopener">青蛙过河</a></p>
<ul>
<li>dp为能否到第i个石子上，并且上一步跳k个单位，限制条件是在i块石子上最多能跳i，如果石子间距离大于i则一定不能到达终点，并且上次跳跃距离一定满足k &lt;= i，如果不满足则可以停止跳跃，避免冗余计算。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(stones)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">    dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> stones[i]-stones[i<span class="number">-1</span>] &gt; i &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">        k := stones[i] - stones[j]</span><br><span class="line">        <span class="keyword">if</span> k &gt; j+<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][k] = dp[j][k<span class="number">-1</span>] || dp[j][k] || dp[j][k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == n<span class="number">-1</span> &amp;&amp; dp[i][k] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p><img src="https://img.shields.io/badge/leetcode-416-blue.svg" alt> <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></p>
<ul>
<li>01背包问题，背包容量是sum/2，商品价值和重量均为元素的数值，背包如何正好装满，说明找到了总和为sum/2的子集，元素不可重复</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10001</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target] == target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h2><p><img src="https://img.shields.io/badge/leetcode-1049-blue.svg" alt> <a href="https://leetcode-cn.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">最后一块石头的重量 II</a></p>
<ul>
<li>01背包，背包容量是sum/2，商品价值和重量均为石头的重量，如何装最大化价值的石头dp[target]，另一部分没装的就是sum - dp[target]，sum/2向下取正，sum &gt; 2dp[target]</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">15001</span>)</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> stones &#123;</span><br><span class="line">        sum += s</span><br><span class="line">    &#125;</span><br><span class="line">    target := sum / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := target; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - dp[target] - dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p><img src="https://img.shields.io/badge/leetcode-494-blue.svg" alt> <a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">目标和</a></p>
<ul>
<li>01背包，加号的总和为x，要求x - (sum  - x) = S，dp[j]表示装满容量为j的背包有dp[i]种方法，那么dp[j] += dp[j - nums[i]]就是把所有可能的方法都加起来</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTargetSumWays</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> target &gt; sum &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target + sum) % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bagSize := (target + sum) / <span class="number">2</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span> , bagSize + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := bagSize; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagSize]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 贪心法</title>
    <url>/cs/algo/greedy/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>贪心法用来解可由局部最优推出全局最优的问题。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>贪心法一般步骤：</p>
<ul>
<li>将问题分解为子问题</li>
<li>找出适合的贪心策略</li>
<li>求子问题的最优解</li>
<li>局部最优堆叠为全局最优</li>
</ul>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p><img src="https://img.shields.io/badge/leetcode-455-blue.svg" alt> <a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">分发饼干</a></p>
<ul>
<li>从最大的开始，依次试图满足孩子的胃口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="keyword">int</span>, s []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    cookie := <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> kid := <span class="built_in">len</span>(g) - <span class="number">1</span>; kid &gt;= <span class="number">0</span>; kid-- &#123;</span><br><span class="line">        <span class="keyword">if</span> cookie &gt;= <span class="number">0</span> &amp;&amp; s[cookie] &gt;= g[kid] &#123;</span><br><span class="line">            count++</span><br><span class="line">            cookie--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p><img src="https://img.shields.io/badge/leetcode-376-blue.svg" alt> <a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">摆动序列</a></p>
<ul>
<li>依次判断前后差值，当差值异号时计入统计，统一拓展至边界值，[2, 5]可以看做[2, 2, 5]是等价的，序列均为2。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    lastDiff := <span class="number">0</span></span><br><span class="line">    curDiff := <span class="number">0</span></span><br><span class="line">    count := <span class="number">1</span> <span class="comment">// 1 by default</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        curDiff = nums[i] - nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> curDiff &gt; <span class="number">0</span> &amp;&amp; lastDiff &lt;= <span class="number">0</span> || lastDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">            lastDiff = curDiff</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p><img src="https://img.shields.io/badge/leetcode-53-blue.svg" alt> <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></p>
<ul>
<li>暴力法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := math.MinInt64</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        count := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            count += nums[j]</span><br><span class="line">            <span class="keyword">if</span> count &gt; max &#123;</span><br><span class="line">                max = count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>贪心，负数总会拉低总和，如果连续和已经为负数就应该立刻放弃。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := math.MinInt64</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        count += nums[i]</span><br><span class="line">        <span class="keyword">if</span> count &gt; max &#123;</span><br><span class="line">            max = count</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count &lt; <span class="number">0</span> &#123;</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p><img src="https://img.shields.io/badge/leetcode-122-blue.svg" alt> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></p>
<ul>
<li>累加所有差为正的区间</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    curDiff := <span class="number">0</span></span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        curDiff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> curDiff &gt; <span class="number">0</span> &#123;</span><br><span class="line">            max += curDiff</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p><img src="https://img.shields.io/badge/leetcode-55-blue.svg" alt> <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></p>
<ul>
<li>计算下标+数值的最大值，如果下标大于最大值说明无法到达</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; max &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i) &gt; max &#123;</span><br><span class="line">            max = nums[i] + i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>考虑覆盖，如果max已覆盖最后一个index，则直接返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= max; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i) &gt; max &#123;</span><br><span class="line">            max = nums[i] + i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h2><p><img src="https://img.shields.io/badge/leetcode-45-blue.svg" alt> <a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">跳跃游戏II</a></p>
<ul>
<li>计算下标+数值的最大值，当当前下标不是最后一个下标时，最大步数总要+1，而两段部分重叠的区间，总可以2步走完。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := <span class="number">0</span></span><br><span class="line">    next := <span class="number">0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] + i &gt; next &#123;</span><br><span class="line">            next = nums[i] + i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == cur &#123;</span><br><span class="line">            <span class="keyword">if</span> cur != <span class="built_in">len</span>(nums) - <span class="number">1</span> &#123;</span><br><span class="line">                ans++</span><br><span class="line">                cur = next</span><br><span class="line">                <span class="keyword">if</span> next &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><p><img src="https://img.shields.io/badge/leetcode-1005-blue.svg" alt> <a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/" target="_blank" rel="noopener">K 次取反后最大化的数组和</a></p>
<ul>
<li>首先按绝对值从大到小排序，把K的次数用在翻转负数上，如果全部翻转完K&gt;0，则全部用在绝对值最小的值上</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> abs(a[i]) &gt; abs(a[j]) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestSumAfterKNegations</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Sort(Arr(A))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(A); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            A[i] = -A[i]</span><br><span class="line">            K--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> K &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> K % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            A[<span class="built_in">len</span>(A) - <span class="number">1</span>] = -A[<span class="built_in">len</span>(A) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;</span><br><span class="line">        sum += a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p><img src="https://img.shields.io/badge/leetcode-134-blue.svg" alt> <a href="https://leetcode-cn.com/problems/gas-station/" target="_blank" rel="noopener">加油站</a></p>
<ul>
<li>贪心，如果gas总量小于cost则不能跑完，否则一定存在起始点，从0开始累加gas-cost差，如果累加和小于0，则之前站点不能作为起始站点，累加和清零，起始点一点出现在当前点或之后。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCompleteCircuit</span><span class="params">(gas []<span class="keyword">int</span>, cost []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    cur := <span class="number">0</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> gas &#123;</span><br><span class="line">        cur += gas[i] - cost[i]</span><br><span class="line">        sum += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span> cur &lt; <span class="number">0</span> &#123;</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p><img src="https://img.shields.io/badge/leetcode-135-blue.svg" alt> <a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">分发糖果</a></p>
<ul>
<li>模拟暴力法，模拟发糖过程，如果当前评分低于前值，从当前位置向前补发糖果</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ratings) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(ratings))</span><br><span class="line">    candies[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(ratings); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i - <span class="number">1</span>] &lt; ratings[i] &#123;</span><br><span class="line">            candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candies[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j := i; j &gt; <span class="number">0</span>; j-- &#123;</span><br><span class="line">                <span class="keyword">if</span> ratings[j] &lt; ratings[j - <span class="number">1</span>] &#123;</span><br><span class="line">                    <span class="keyword">if</span> candies[j - <span class="number">1</span>] &lt;= candies[j] &#123;</span><br><span class="line">                        candies[j - <span class="number">1</span>] = candies[j] + <span class="number">1</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        sum += c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>贪心，先满足右边，再满足左边，满足左边时右边的条件也不能被破坏</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ratings) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    candies := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(ratings))</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        candies[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(ratings); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i - <span class="number">1</span>] &#123;</span><br><span class="line">            candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(ratings) - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i + <span class="number">1</span>] &#123;</span><br><span class="line">            candies[i] = max(candies[i], candies[i + <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        sum += c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p><img src="https://img.shields.io/badge/leetcode-860-blue.svg" alt> <a href="https://leetcode-cn.com/problems/lemonade-change/" target="_blank" rel="noopener">柠檬水找零</a></p>
<ul>
<li>模拟暴力法，模拟发糖过程，如果当前评分低于前值，从当前位置向前补发糖果</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lemonadeChange</span><span class="params">(bills []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left5 := <span class="number">0</span></span><br><span class="line">    left10 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(bills); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> bills[i] == <span class="number">5</span> &#123;</span><br><span class="line">            left5++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bills[i] == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> left5 &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                left5--</span><br><span class="line">                left10++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bills[i] == <span class="number">20</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> left5 &gt;= <span class="number">1</span> &amp;&amp; left10 &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                left5--</span><br><span class="line">                left10--</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> left5 &gt;= <span class="number">3</span> &#123;</span><br><span class="line">                left5 -= <span class="number">3</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p><img src="https://img.shields.io/badge/leetcode-406-blue.svg" alt> <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></p>
<ul>
<li>先按身高从大到小排列，身高相同时，k按从小到大排列，再按k的序号顺序插入即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr [][]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[i][<span class="number">0</span>] &gt; a[j][<span class="number">0</span>] || a[i][<span class="number">0</span>] == a[j][<span class="number">0</span>] &amp;&amp; a[i][<span class="number">1</span>] &lt; a[j][<span class="number">1</span>] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Sort(Arr(people))</span><br><span class="line">    <span class="comment">// fmt.Printf("%v\n", people)</span></span><br><span class="line">    queue := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(people))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(people); i++ &#123;</span><br><span class="line">        <span class="comment">// fmt.Printf("%v\n", queue)</span></span><br><span class="line">        pos := people[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= pos; j-- &#123;</span><br><span class="line">            queue[j+<span class="number">1</span>] = queue[j]</span><br><span class="line">        &#125;</span><br><span class="line">        queue[pos] = people[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组shift改成copy，好像并没有变快很多</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr [][]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[i][<span class="number">0</span>] &gt; a[j][<span class="number">0</span>] || a[i][<span class="number">0</span>] == a[j][<span class="number">0</span>] &amp;&amp; a[i][<span class="number">1</span>] &lt; a[j][<span class="number">1</span>] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reconstructQueue</span><span class="params">(people [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    sort.Sort(Arr(people))</span><br><span class="line">    <span class="comment">// fmt.Printf("%v\n", people)</span></span><br><span class="line">    queue := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(people))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(people); i++ &#123;</span><br><span class="line">        <span class="comment">// fmt.Printf("%v\n", queue)</span></span><br><span class="line">        pos := people[i][<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">copy</span>(queue[pos+<span class="number">1</span>:],queue[pos:])</span><br><span class="line">        queue[pos] = people[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p><img src="https://img.shields.io/badge/leetcode-452-blue.svg" alt> <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">用最少数量的箭引爆气球</a></p>
<ul>
<li>先按气球左边界从小到大排序，再逐一引爆气球，如果当前气球的右边界小于前一个气球的左边界，则是重叠的，可以引爆，此时合二为一，取两者交集（右边界中较小的），反之，需要一只箭。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr [][]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[i][<span class="number">0</span>] &lt; a[j][<span class="number">0</span>] || a[i][<span class="number">0</span>] == a[j][<span class="number">0</span>] &amp;&amp; a[i][<span class="number">1</span>] &lt; a[j][<span class="number">1</span>] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    sort.Sort(Arr(points))</span><br><span class="line">    arrow := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(points); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[i<span class="number">-1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            arrow++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            points[i][<span class="number">1</span>] = min(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p><img src="https://img.shields.io/badge/leetcode-435-blue.svg" alt> <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">无重叠区间</a></p>
<ul>
<li>先按左边界从小到大排序，再逐一判断是否交叠，如果当前左边界小于右边界，说明发生交叠，必须移除一个，此时选择右边界更小的局部最优解，尽量避免和其他区间交叠。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Arr [][]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Arr)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a[i][<span class="number">0</span>] &lt; a[j][<span class="number">0</span>] || a[i][<span class="number">0</span>] == a[j][<span class="number">0</span>] &amp;&amp; a[i][<span class="number">1</span>] &lt; a[j][<span class="number">1</span>] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eraseOverlapIntervals</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Sort(Arr(intervals))</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>] &#123;</span><br><span class="line">            count++</span><br><span class="line">            intervals[i][<span class="number">1</span>] = min(intervals[i - <span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p><img src="https://img.shields.io/badge/leetcode-763-blue.svg" alt> <a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">划分字母区间</a></p>
<ul>
<li>先遍历找到每个字母的最远边界，再从头开始，如果当前字母的最远边界大于右边界，则将右边界更新为当前字母最远边界，如果遍历index等于右边界，说明右边界内所有值的最远程度均小于等于右边界，形成一个分割点。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionLabels</span><span class="params">(S <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(S); i++ &#123;</span><br><span class="line">        m[<span class="keyword">int</span>(S[i]) - <span class="keyword">int</span>(<span class="string">'a'</span>)] = i</span><br><span class="line">    &#125;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="number">0</span></span><br><span class="line">    res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(S); i++ &#123;</span><br><span class="line">        right = max(right, m[<span class="keyword">int</span>(S[i]) - <span class="keyword">int</span>(<span class="string">'a'</span>)])</span><br><span class="line">        <span class="keyword">if</span> i == right &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, right - left + <span class="number">1</span>)</span><br><span class="line">            left = right + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://img.shields.io/badge/leetcode-56-blue.svg" alt> <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></p>
<ul>
<li>同区间重叠</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">	sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">0</span>]</span><br><span class="line">	&#125;)</span><br><span class="line">    left := intervals[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    right := intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt;= right &#123;</span><br><span class="line">            right = max(intervals[i][<span class="number">1</span>], right)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;left, right&#125;)</span><br><span class="line">            left, right = intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;left, right&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p><img src="https://img.shields.io/badge/leetcode-738-blue.svg" alt> <a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字</a></p>
<ul>
<li>贪心策略，如果前一位较大，则将前一位减一，当前位置为9。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    num := []<span class="keyword">rune</span>(fmt.Sprintf(<span class="string">"%v"</span>, N))</span><br><span class="line">    start := <span class="built_in">len</span>(num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(num) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> num[i - <span class="number">1</span>] &gt; num[i] &#123;</span><br><span class="line">            start = i</span><br><span class="line">            num[i - <span class="number">1</span>] = <span class="keyword">rune</span>(<span class="keyword">int</span>(num[i - <span class="number">1</span>]) - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">        num[i] = <span class="string">'9'</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret, _ := strconv.Atoi(<span class="keyword">string</span>(num))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-968-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">监控二叉树</a></p>
<ul>
<li>贪心策略，为了最小化摄像头数量，叶子节点不放，根节点最好也不放，其余节点隔两个放一个，从叶子节点开始后序遍历。节点状态分为0无覆盖，1有摄像头，2有覆盖三种，空节点默认为有覆盖。</li>
</ul>
<p>处理逻辑分为：</p>
<ul>
<li>左右节点都有覆盖则返回无覆盖</li>
<li>左右至少有一个无覆盖则放置摄像头</li>
<li>左右节点至少有一个摄像头则返回有覆盖</li>
<li>根节点如果无覆盖则放置摄像头</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCameraCover</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">int</span></span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left := traverse(node.Left)</span><br><span class="line">        right := traverse(node.Right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> || right == <span class="number">0</span> &#123; </span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> || right == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> traverse(root) == <span class="number">0</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 哈希表</title>
    <url>/cs/algo/hash-table/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈希函数用于缩小映射空间，可能会发生碰撞，可用链表法或多哈希函数。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>常用数据结构：</p>
<ul>
<li>数组，有限确定项，比如字母串</li>
<li>map，映射</li>
<li>set，集合</li>
</ul>
<p>Go的map底层使用哈希表实现，set可通过将map的value置空实现。<br>C++的std::map/std::multimap由红黑树实现，std::unorderd_map由哈希表实现。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="数组判断有效字母异位词"><a href="#数组判断有效字母异位词" class="headerlink" title="数组判断有效字母异位词"></a>数组判断有效字母异位词</h2><p><img src="https://img.shields.io/badge/leetcode-242-blue.svg" alt> <a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></p>
<ul>
<li>数组直接存储</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a,b [<span class="number">26</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i:= <span class="keyword">range</span> s &#123;</span><br><span class="line">        a[i-<span class="string">'a'</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, i:= <span class="keyword">range</span> t &#123;</span><br><span class="line">        b[i-<span class="string">'a'</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a==b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><img src="https://img.shields.io/badge/leetcode-242-blue.svg" alt> <a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词</a></p>
<ul>
<li>数组直接存储</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r [<span class="number">26</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">        r[c - <span class="string">'a'</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line">        <span class="keyword">if</span> r[c - <span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        r[c - <span class="string">'a'</span>]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合判断数组相交"><a href="#集合判断数组相交" class="headerlink" title="集合判断数组相交"></a>集合判断数组相交</h2><p><img src="https://img.shields.io/badge/leetcode-349-blue.svg" alt> <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">两个数组的交集</a></p>
<ul>
<li>集合存储</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span><span class="title">Add</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[n] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span><span class="title">And</span><span class="params">(t Set)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        s, t = t, s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := t[k]; ok &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := Set&#123;&#125;, Set&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">        a.Add(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">        b.Add(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.And(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合判断快乐数"><a href="#集合判断快乐数" class="headerlink" title="集合判断快乐数"></a>集合判断快乐数</h2><p><img src="https://img.shields.io/badge/leetcode-202-blue.svg" alt> <a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">快乐数</a></p>
<ul>
<li>集合存储</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">happy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        s := n % <span class="number">10</span></span><br><span class="line">        sum += s * s</span><br><span class="line">        n /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   set := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">       sum := happy(n)</span><br><span class="line">       <span class="keyword">if</span> sum == <span class="number">1</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> _, ok := set[sum]; ok &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           set[sum] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       n = sum</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射存储两数之和"><a href="#映射存储两数之和" class="headerlink" title="映射存储两数之和"></a>映射存储两数之和</h2><p><img src="https://img.shields.io/badge/leetcode-1-blue.svg" alt> <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v, ok := m[target - n]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;v, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[n] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="映射统计四数相加结果次数"><a href="#映射统计四数相加结果次数" class="headerlink" title="映射统计四数相加结果次数"></a>映射统计四数相加结果次数</h2><p><img src="https://img.shields.io/badge/leetcode-454-blue.svg" alt> <a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">四数相加 II</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(A []<span class="keyword">int</span>, B []<span class="keyword">int</span>, C []<span class="keyword">int</span>, D []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> B &#123;</span><br><span class="line">            m[a + b]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> C &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> D &#123;</span><br><span class="line">            <span class="keyword">if</span> v, ok := m[-c-d]; ok &#123;</span><br><span class="line">                count += v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="员工的重要性"><a href="#员工的重要性" class="headerlink" title="员工的重要性"></a>员工的重要性</h2><p><img src="https://img.shields.io/badge/leetcode-690-blue.svg" alt> <a href="https://leetcode-cn.com/problems/employee-importance/" target="_blank" rel="noopener">员工的重要性</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for Employee.</span></span><br><span class="line"><span class="comment"> * type Employee struct &#123;</span></span><br><span class="line"><span class="comment"> *     Id int</span></span><br><span class="line"><span class="comment"> *     Importance int</span></span><br><span class="line"><span class="comment"> *     Subordinates []int</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getImportance</span><span class="params">(employees []*Employee, id <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*Employee)</span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">        m[e.Id] = e</span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    queue := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, id)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        id = queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> e, ok := m[id]; ok &#123;</span><br><span class="line">            count += e.Importance</span><br><span class="line">            <span class="keyword">for</span> _, sub := <span class="keyword">range</span> e.Subordinates &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, sub)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 链表</title>
    <url>/cs/algo/list/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>表是最基础的数据结构之一，存储线性数据，内存结构不连续。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>链表可通过自定义数据结构，使用指针或引用指向前后节点。</p>
<p>Go提供了”container/list”<a href="#refer-1"><sup>1</sup></a>标准库实现双向链表。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"container/list"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create a new list and put some numbers in it.</span></span><br><span class="line">	l := list.New()</span><br><span class="line">	e4 := l.PushBack(<span class="number">4</span>)</span><br><span class="line">	e1 := l.PushFront(<span class="number">1</span>)</span><br><span class="line">	l.InsertBefore(<span class="number">3</span>, e4)</span><br><span class="line">	l.InsertAfter(<span class="number">2</span>, e1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate through list and print its contents.</span></span><br><span class="line">	<span class="keyword">for</span> e := l.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		fmt.Println(e.Value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="虚拟头结点移除链表中指定元素"><a href="#虚拟头结点移除链表中指定元素" class="headerlink" title="虚拟头结点移除链表中指定元素"></a>虚拟头结点移除链表中指定元素</h2><p><img src="https://img.shields.io/badge/leetcode-203-blue.svg" alt> <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素</a></p>
<ul>
<li>基本链表操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    vhead := &amp;ListNode&#123;<span class="number">0</span>,head&#125;</span><br><span class="line">    head = vhead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &amp;&amp; head.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head.Next.Val == val &#123;</span><br><span class="line">            head.Next = head.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vhead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现链表基本操作"><a href="#实现链表基本操作" class="headerlink" title="实现链表基本操作"></a>实现链表基本操作</h2><p><img src="https://img.shields.io/badge/leetcode-707-blue.svg" alt> <a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">设计链表</a></p>
<ul>
<li>单向链表</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val  <span class="keyword">int</span></span><br><span class="line">	Next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">	size <span class="keyword">int</span></span><br><span class="line">	head *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyLinkedList</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> MyLinkedList&#123;</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		&amp;Node&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">Get</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.size &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	prev := this.head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">		prev = prev.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> prev.Next.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">AddAtHead</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	this.AddAtIndex(<span class="number">0</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">AddAtTail</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	this.AddAtIndex(this.size, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">AddAtIndex</span><span class="params">(index <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt; this.size &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	prev := this.head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">		prev = prev.Next</span><br><span class="line">	&#125;</span><br><span class="line">	node := &amp;Node&#123;Val: val&#125;</span><br><span class="line">	node.Next = prev.Next</span><br><span class="line">	prev.Next = node</span><br><span class="line"></span><br><span class="line">	this.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">DeleteAtIndex</span><span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= this.size &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	prev := this.head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; index; i++ &#123;</span><br><span class="line">		prev = prev.Next</span><br><span class="line">	&#125;</span><br><span class="line">	prev.Next = prev.Next.Next</span><br><span class="line"></span><br><span class="line">	this.size--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(index);</span></span><br><span class="line"><span class="comment"> * obj.AddAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.DeleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="keyword">int</span></span><br><span class="line">    Next *Node</span><br><span class="line">    Prev *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyLinkedList <span class="keyword">struct</span> &#123;</span><br><span class="line">    Head *Node</span><br><span class="line">    Tail *Node</span><br><span class="line">    Length <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyLinkedList</span></span> &#123;</span><br><span class="line">    head := &amp;Node&#123;&#125;</span><br><span class="line">    tail := &amp;Node&#123;&#125;</span><br><span class="line">    head.Next = tail</span><br><span class="line">    tail.Prev = head</span><br><span class="line">    <span class="keyword">return</span> MyLinkedList&#123;</span><br><span class="line">        Head: head,</span><br><span class="line">        Tail: tail,</span><br><span class="line">        Length: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">Print</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"---%v---\n"</span>, str)</span><br><span class="line">    pt := this.Head</span><br><span class="line">    fmt.Printf(<span class="string">"head %v\n"</span>, pt)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= this.Length; i++&#123;</span><br><span class="line">        pt = pt.Next</span><br><span class="line">        fmt.Printf(<span class="string">"%v %v\n"</span>, i, pt)</span><br><span class="line">    &#125;</span><br><span class="line">    pt = pt.Next</span><br><span class="line">    fmt.Printf(<span class="string">"tail %v\n"</span>, pt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">Get</span><span class="params">(index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt;= this.Length &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := this.Head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= index; i++ &#123;</span><br><span class="line">        ret = ret.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">AddAtHead</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    node := &amp;Node&#123;</span><br><span class="line">        Val: val,</span><br><span class="line">        Next: this.Head.Next,</span><br><span class="line">        Prev: this.Head,</span><br><span class="line">    &#125;</span><br><span class="line">    this.Head.Next.Prev = node</span><br><span class="line">    this.Head.Next = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> this.Tail.Prev.Prev == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.Tail.Prev = this.Head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    this.Length++</span><br><span class="line">    <span class="comment">// this.Print("AddAtHead")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">AddAtTail</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    node := &amp;Node&#123;</span><br><span class="line">        Val: val,</span><br><span class="line">        Next: this.Tail,</span><br><span class="line">        Prev: this.Tail.Prev,</span><br><span class="line">    &#125;</span><br><span class="line">    this.Tail.Prev.Next = node</span><br><span class="line">    this.Tail.Prev = node</span><br><span class="line">    <span class="keyword">if</span> this.Head.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        this.Head.Next = this.Tail.Prev</span><br><span class="line">    &#125;</span><br><span class="line">    this.Length++</span><br><span class="line">    <span class="comment">// this.Print("AddAtTail")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">AddAtIndex</span><span class="params">(index <span class="keyword">int</span>, val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> index == this.Length &#123;</span><br><span class="line">        this.AddAtTail(val)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">        this.AddAtHead(val)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pt *Node</span><br><span class="line">    pt = this.Head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= index; i++ &#123;</span><br><span class="line">        pt = pt.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node := &amp;Node&#123;</span><br><span class="line">        Val: val,</span><br><span class="line">        Next: pt,</span><br><span class="line">        Prev: pt.Prev,</span><br><span class="line">    &#125;</span><br><span class="line">    pt.Prev.Next = node</span><br><span class="line">    pt.Prev = node</span><br><span class="line">    this.Length++</span><br><span class="line">    <span class="comment">// this.Print("AddAtIndex")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyLinkedList)</span> <span class="title">DeleteAtIndex</span><span class="params">(index <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> index &gt;= this.Length &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">        index = this.Length + index</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pt *Node</span><br><span class="line">    pt = this.Head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= index; i++ &#123;</span><br><span class="line">        pt = pt.Next</span><br><span class="line">    &#125;</span><br><span class="line">    pt.Prev.Next = pt.Next</span><br><span class="line">    pt.Next.Prev = pt.Prev</span><br><span class="line">    this.Length--</span><br><span class="line">    <span class="comment">// this.Print("DeleteAtIndex")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(index);</span></span><br><span class="line"><span class="comment"> * obj.AddAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.AddAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.DeleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><img src="https://img.shields.io/badge/leetcode-206-blue.svg" alt> <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></p>
<ul>
<li>构建新链表</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    pt := head</span><br><span class="line">    <span class="keyword">var</span> tail *ListNode</span><br><span class="line">    <span class="keyword">for</span> pt != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail = &amp;ListNode&#123;</span><br><span class="line">            pt.Val,</span><br><span class="line">            tail,</span><br><span class="line">        &#125;</span><br><span class="line">        pt = pt.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>双指针法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre, temp *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        temp = cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="环形链表的入环节点"><a href="#环形链表的入环节点" class="headerlink" title="环形链表的入环节点"></a>环形链表的入环节点</h2><p><img src="https://img.shields.io/badge/leetcode-141-blue.svg" alt> <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a><br><img src="https://img.shields.io/badge/leetcode-142-blue.svg" alt> <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">环形链表II</a></p>
<ul>
<li>快慢指针法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            p1 := fast</span><br><span class="line">            p2 := head</span><br><span class="line">            <span class="keyword">for</span> p1 != p2 &#123;</span><br><span class="line">                p1 = p1.Next</span><br><span class="line">                p2 = p2.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除排序链表中的重复元素-II"><a href="#删除排序链表中的重复元素-II" class="headerlink" title="删除排序链表中的重复元素 II"></a>删除排序链表中的重复元素 II</h2><p><img src="https://img.shields.io/badge/leetcode-82-blue.svg" alt> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></p>
<ul>
<li>操作指针，开始指针，结束指针。注意绝对不重复的条件是开始指针和结束指针相邻且不相等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123; <span class="keyword">return</span> head &#125;</span><br><span class="line">    vhead := &amp;ListNode&#123;Next:head&#125;</span><br><span class="line">    cur := vhead</span><br><span class="line">    start := vhead.Next</span><br><span class="line">    end := vhead.Next.Next</span><br><span class="line">    <span class="keyword">for</span> start != <span class="literal">nil</span> &amp;&amp; end != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start.Val != end.Val &#123;</span><br><span class="line">            <span class="keyword">if</span> end == start.Next &#123;</span><br><span class="line">                cur = cur.Next</span><br><span class="line">            &#125;</span><br><span class="line">            start = end</span><br><span class="line">            end = end.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = end.Next</span><br><span class="line">            cur.Next = end</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vhead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://golang.org/pkg/container/list/" target="_blank" rel="noopener">Package list</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 优先队列</title>
    <url>/cs/algo/priority-queue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>优先队列以比排序更小的代价维护顺序。二叉堆是实现优先队列的一种实现。二叉堆的最简单实现是数组。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>堆的基本操作：</p>
<ul>
<li>插入</li>
<li>堆化，Sift Up，Sift Down</li>
<li>取出最值</li>
</ul>
<p>使用数组表示的二叉堆的基本性质：</p>
<p><img src="/images/priority_queue_heap.svg" alt="二叉堆的数组表示"></p>
<ul>
<li>每个结点的左孩子为下标i的2倍：left child(i) = i <em> 2；每个结点的右孩子为下标i的2倍加1：right child(i) = i </em> 2 + 1</li>
<li>每个结点的父亲结点为下标的二分之一：parent(i) = i / 2，注意这里是整数除，2和3除以2都为1，大家可以验证一下</li>
<li>注意：这里是把下标为0的地方空出来了的，主要是为了方便理解，如果0不空出来只需要在计算的时候把i值往右偏移一个位置就行了（也就是加1）</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>Go标准库提供了”container/heap”<a href="#refer-2"><sup>2</sup></a>封装了堆的基本操作。默认最小堆。</p>
<p>可以自定义struct，并重载method：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>重载Less为Greater逻辑即可获得最大堆。</p>
<h2 id="Heapify"><a href="#Heapify" class="headerlink" title="Heapify"></a>Heapify</h2><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p><img src="https://img.shields.io/badge/leetcode-23-blue.svg" alt> <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个升序链表</a></p>
<p>优先队列合并，先顺序push所有链表最小值，在根据堆顶元素push下个值，时间复杂度O(kn * logk)，空间复杂度O(k)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"container/heap"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNodeHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h ListNodeHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h ListNodeHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i].Val &lt; h[j].Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h ListNodeHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ListNodeHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *ListNodeHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n - <span class="number">1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> q ListNodeHeap</span><br><span class="line">    <span class="keyword">for</span> _, nodePtr := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodePtr != <span class="literal">nil</span>) &#123;</span><br><span class="line">            q = <span class="built_in">append</span>(q, nodePtr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    heap.Init(&amp;q)</span><br><span class="line"></span><br><span class="line">    head := ListNode&#123;&#125;</span><br><span class="line">    tail := &amp;head</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        nodePtr := heap.Pop(&amp;q).(*ListNode)</span><br><span class="line">        tail.Next = nodePtr</span><br><span class="line">        tail = tail.Next</span><br><span class="line">        <span class="keyword">if</span> nodePtr.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(&amp;q, nodePtr.Next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他方法：</p>
<ul>
<li>遍历插入，时间复杂度为O(k<sup>2</sup>n)，空间复杂度为O(1)</li>
<li>分治合并，时间复杂度为O(kn * logk)，空间复杂度为O(logk)</li>
</ul>
<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p><img src="https://img.shields.io/badge/leetcode-215-blue.svg" alt> <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></p>
<p>构建优先队列，并删除k次</p>
<p>其他方法：</p>
<ul>
<li>快排，取n-k个元素</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Array []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Array)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Array)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Array)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt; a[j] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    array := Array(nums)</span><br><span class="line">    sort.Sort(array)</span><br><span class="line">    <span class="keyword">return</span> array[<span class="built_in">len</span>(nums) - k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p><img src="https://img.shields.io/badge/leetcode-347-blue.svg" alt> <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前K个高频元素</a></p>
<p>map统计，优先队列取前K个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span>&#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">    Freq <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap []*Node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h[i].Freq &gt; h[j].Freq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    h[i], h[j] = h[j], h[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(*Node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n - <span class="number">1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">topKFrequent</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    freqs := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        freqs[n]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> q IntHeap</span><br><span class="line">    heap.Init(&amp;q)</span><br><span class="line">    <span class="keyword">for</span> num, freq := <span class="keyword">range</span> freqs &#123;</span><br><span class="line">        <span class="comment">// fmt.Printf("%v, %v\n", num, freq)</span></span><br><span class="line">        heap.Push(&amp;q, &amp;Node&#123;</span><br><span class="line">            num, freq,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, heap.Pop(&amp;q).(*Node).Num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://zhuanlan.zhihu.com/p/39615266" target="_blank" rel="noopener">数据结构与算法(4)——优先队列和堆 - 知乎</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://golang.org/pkg/container/heap/" target="_blank" rel="noopener">Package heap</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 队列</title>
    <url>/cs/algo/queue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>队列是线性结构，遵循FIFO原则。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>队列的底层可由数组或链表实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue Queue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(queue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(queue) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue Queue)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cap</span>(queue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">    *queue = <span class="built_in">append</span>(*queue, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue Queue)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(queue) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;  &#123;</span><br><span class="line">    refQueue := *queue</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(refQueue) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    value := refQueue[<span class="number">0</span>]</span><br><span class="line">    *queue = refQueue[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="单调队列求滑动窗口最大值"><a href="#单调队列求滑动窗口最大值" class="headerlink" title="单调队列求滑动窗口最大值"></a>单调队列求滑动窗口最大值</h2><p><img src="https://img.shields.io/badge/leetcode-239-blue.svg" alt> <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></p>
<ul>
<li>单调队列。单调队列的性质是维持有序序列，最值位于最头部，常用于不断有值替换（去除最久的，加入最新的）的场景中取最值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MonoQueue []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MonoQueue)</span><span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mref := *m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(mref) &gt; <span class="number">0</span> &amp;&amp; val &gt; mref[<span class="built_in">len</span>(mref) - <span class="number">1</span>] &#123;</span><br><span class="line">        mref = mref[:<span class="built_in">len</span>(mref) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    *m = <span class="built_in">append</span>(mref, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MonoQueue)</span><span class="title">Pop</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mref := *m</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mref) &gt; <span class="number">0</span> &amp;&amp; val == mref[<span class="number">0</span>] &#123;</span><br><span class="line">        mref = mref[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    *m = mref</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MonoQueue)</span><span class="title">Front</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*m)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ret := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    m := MonoQueue&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        m.Push(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">append</span>(ret, m.Front())</span><br><span class="line">    <span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        m.Pop(nums[i - k])</span><br><span class="line">        m.Push(nums[i])</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, m.Front())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 排序</title>
    <url>/cs/algo/sort/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>排序是最常用的操作。</p>
<a id="more"></a>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快排(QUICK-SORT)基于分治思想，核心是对子数组partition，partition挑选一个参考基准(主元，通常为第一个或最后一个元素)，以主元为分界将数据分为两份，子数组递归partition。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QUICKSORT</span></span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">   then q ← PARTITION(A, p, r)</span><br><span class="line">        QUICKSORT(A, p, q - <span class="number">1</span>)</span><br><span class="line">        QUICKSORT(A, q + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PARTITION</span></span><br><span class="line">x ← A[r]</span><br><span class="line">i ← p - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j ← p to r - <span class="number">1</span></span><br><span class="line">     do <span class="keyword">if</span> A[j] ≤ x</span><br><span class="line">           then i ← i + <span class="number">1</span></span><br><span class="line">                exchange A[i] &lt;-&gt; A[j]</span><br><span class="line">exchange A[i + <span class="number">1</span>] &lt;-&gt; A[r]</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GoLang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(a []<span class="keyword">int</span>, lo, hi <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	pivot := a[hi]</span><br><span class="line">	i := lo - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j := lo; j &lt; hi; j++ &#123;</span><br><span class="line">		<span class="keyword">if</span> a[j] &lt; pivot &#123;</span><br><span class="line">			i++</span><br><span class="line">			a[j], a[i] = a[i], a[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a[i+<span class="number">1</span>], a[hi] = a[hi], a[i+<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(a []<span class="keyword">int</span>, lo, hi <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lo &gt;= hi &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	p := partition(a, lo, hi)</span><br><span class="line">	quickSort(a, lo, p<span class="number">-1</span>)</span><br><span class="line">	quickSort(a, p+<span class="number">1</span>, hi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序(MERGE-SORT)使用分治思想，每两个有序数组相互比较合并。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://zhuanlan.zhihu.com/p/39615266" target="_blank" rel="noopener">数据结构与算法(4)——优先队列和堆 - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 栈</title>
    <url>/cs/algo/stack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈是线性结构，遵循FILO原则。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>栈的底层可由数组或链表实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack []<span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cap</span>(stack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">    *stack = <span class="built_in">append</span>(*stack, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack Stack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;  &#123;</span><br><span class="line">    refStack := *stack</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(refStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    value := refStack[<span class="built_in">len</span>(refStack) - <span class="number">1</span>]</span><br><span class="line">    *stack = refStack[:<span class="built_in">len</span>(refStack) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h2><p><img src="https://img.shields.io/badge/leetcode-232-blue.svg" alt> <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">用栈实现队列</a></p>
<ul>
<li>查看队列首个元素时检查出栈是否为空，如果已排空，则将入栈元素依次压入出栈中</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    i,o []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.i = <span class="built_in">append</span>(this.i, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := this.Peek()</span><br><span class="line">    this.o = this.o[:<span class="built_in">len</span>(this.o) - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.o) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(this.i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            this.o = <span class="built_in">append</span>(this.o, this.i[<span class="built_in">len</span>(this.i) - <span class="number">1</span>])</span><br><span class="line">            this.i = this.i[:<span class="built_in">len</span>(this.i) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.o[<span class="built_in">len</span>(this.o) - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.o) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.i) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p><img src="https://img.shields.io/badge/leetcode-225-blue.svg" alt> <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">用队列实现栈</a></p>
<ul>
<li>队列1记录，队列2备份，top/pop需要循环取出最近插入的值。也可以把值循环放在push做。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    i, o []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyStack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.i = <span class="built_in">append</span>(this.i, x)</span><br><span class="line">    <span class="comment">// fmt.Printf("PUSH %v, %v\n", this.i, this.o)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(this.i) == <span class="number">1</span> &#123;</span><br><span class="line">            ret = this.i[<span class="number">0</span>]</span><br><span class="line">            this.i = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        this.o = <span class="built_in">append</span>(this.o, this.i[<span class="number">0</span>])</span><br><span class="line">        this.i = this.i[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.o) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        this.i = <span class="built_in">append</span>(this.i, this.o[<span class="number">0</span>])</span><br><span class="line">        this.o = this.o[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Printf("POP %v, %v\n", this.i, this.o)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.i) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(this.i) == <span class="number">1</span> &#123;</span><br><span class="line">            ret = this.i[<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        this.o = <span class="built_in">append</span>(this.o, this.i[<span class="number">0</span>])</span><br><span class="line">        this.i = this.i[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.o) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        this.i = <span class="built_in">append</span>(this.i, this.o[<span class="number">0</span>])</span><br><span class="line">        this.o = this.o[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Printf("TOP %v, %v\n", this.i, this.o)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.i) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="栈判断有效的括号"><a href="#栈判断有效的括号" class="headerlink" title="栈判断有效的括号"></a>栈判断有效的括号</h2><p><img src="https://img.shields.io/badge/leetcode-20-blue.svg" alt> <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    stack := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, <span class="keyword">int</span>(c))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        t := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; t == <span class="string">'('</span> ||</span><br><span class="line">            c == <span class="string">'&#125;'</span> &amp;&amp; t == <span class="string">'&#123;'</span> ||</span><br><span class="line">            c == <span class="string">']'</span> &amp;&amp; t == <span class="string">'['</span>) &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈删除字符串中的所有相邻重复项"><a href="#栈删除字符串中的所有相邻重复项" class="headerlink" title="栈删除字符串中的所有相邻重复项"></a>栈删除字符串中的所有相邻重复项</h2><p><img src="https://img.shields.io/badge/leetcode-1047-blue.svg" alt> <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">删除字符串中的所有相邻重复项</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(S <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    stack := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>] == S[i] &#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, S[i])</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈实现逆波兰表达式求值"><a href="#栈实现逆波兰表达式求值" class="headerlink" title="栈实现逆波兰表达式求值"></a>栈实现逆波兰表达式求值</h2><p><img src="https://img.shields.io/badge/leetcode-150-blue.svg" alt> <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evalRPN</span><span class="params">(tokens []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> stack []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> tokens &#123;</span><br><span class="line">		size := <span class="built_in">len</span>(stack)</span><br><span class="line">		<span class="keyword">switch</span> val &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">			stack = <span class="built_in">append</span>(stack[:size<span class="number">-2</span>], stack[size<span class="number">-2</span>]+stack[size<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">			stack = <span class="built_in">append</span>(stack[:size<span class="number">-2</span>], stack[size<span class="number">-2</span>]-stack[size<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">			stack = <span class="built_in">append</span>(stack[:size<span class="number">-2</span>], stack[size<span class="number">-2</span>]*stack[size<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">			stack = <span class="built_in">append</span>(stack[:size<span class="number">-2</span>], stack[size<span class="number">-2</span>]/stack[size<span class="number">-1</span>])</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			val, _ := strconv.Atoi(val)</span><br><span class="line">			stack = <span class="built_in">append</span>(stack, val)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础 - 树</title>
    <url>/cs/algo/tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树是常用的数据结构，应用较多的有二叉搜索树，二叉平衡搜索树(AVL树)，红黑树，多路平衡搜索树(B-树，B+树，B*树)等。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>树可由链式结构或数组实现，遍历方式为前、中、后、层序遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  Val   <span class="keyword">int</span></span><br><span class="line">  Left  *TreeNode</span><br><span class="line">  Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>有向无环非线性数据结构，每个节点可以指向多个节点，但至多有一个节点指向自身。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>每个节点至多只能指向两个节点。</p>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>只有度为0和2的节点，并且度为0的节点在同一层上。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>除了最底层节点可能没填满外，其余层节点数均达到最大值，并且最下面一层的节点应集中在最左侧。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>一种朴素的有序树结构，左子节点均小于父节点，右子节点均大于父节点。当插入新值时由根节点开始按以上规则逐层比较，直到找到合适的叶节点位置。</p>
<ul>
<li>优点：不需要在插入数据时调整结构</li>
<li>缺点：性能易受数据插入顺序影响，最差情况为顺序插入，退化为链表。</li>
</ul>
<h2 id="平衡二叉搜索树-AVL树"><a href="#平衡二叉搜索树-AVL树" class="headerlink" title="平衡二叉搜索树(AVL树)"></a>平衡二叉搜索树(AVL树)</h2><p>二叉搜索树的改进，又称AVL(Adelson-Velsky and Landis)树，引入平衡因子，通过旋转操作保证所有子树高度差不超过1。</p>
<ul>
<li>优点：相比二叉树更平衡，极端情况下表现依然足够好。</li>
<li>缺点：在读写比例差不多的情况下，旋转操作过多。</li>
</ul>
<h2 id="红黑树-RB树"><a href="#红黑树-RB树" class="headerlink" title="红黑树(RB树)"></a>红黑树(RB树)</h2><p>AVL树的改进，引入着色规则，通过旋转和着色操作保证所有子树高度差不超过2。Map可以通过红黑树实现。</p>
<ul>
<li>优点：写性能更高。</li>
<li>缺点：查询性能弱于AVL树，因为子树高度差比AVL多一层，最差情况会多一次比较。</li>
</ul>
<h2 id="B-树-B-Tree-B树"><a href="#B-树-B-Tree-B树" class="headerlink" title="B-树(B-Tree, B树)"></a>B-树(B-Tree, B树)</h2><p>多路搜索树，又称B树，用于数据索引，子节点内放指针和数据块。通过分裂操作维持树结构。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B-树改进型，子节点内不放数据块，统一放在叶节点内。查询性能稳定，IO数据利用率高。</p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>B+树改进型，增加子节点间指针，如果兄弟节点数据未满，则将一部分指针移到兄弟节点，并修改父节点关键字，将结点的最低利用率从1/2提高到2/3。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p><img src="https://img.shields.io/badge/leetcode-144-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(n *TreeNode, result *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    *result = <span class="built_in">append</span>(*result, n.Val)</span><br><span class="line">    traverse(n.Left, result)</span><br><span class="line">    traverse(n.Right, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    traverse(root, &amp;result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">    result = <span class="built_in">append</span>(result, preorderTraversal(root.Left)...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, preorderTraversal(root.Right)...)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, <span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p><img src="https://img.shields.io/badge/leetcode-145-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, postorderTraversal(root.Left)...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, postorderTraversal(root.Right)...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p><img src="https://img.shields.io/badge/leetcode-94-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, inorderTraversal(root.Left)...)</span><br><span class="line">    result = <span class="built_in">append</span>(result, root.Val)</span><br><span class="line">    result = <span class="built_in">append</span>(result, inorderTraversal(root.Right)...)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">            result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><p><img src="https://img.shields.io/badge/leetcode-102-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></p>
<ul>
<li>队列先进先出</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        vec := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            vec = <span class="built_in">append</span>(vec, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, vec)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的层序遍历II"><a href="#二叉树的层序遍历II" class="headerlink" title="二叉树的层序遍历II"></a>二叉树的层序遍历II</h2><p><img src="https://img.shields.io/badge/leetcode-107-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层序遍历II</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        vec := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            vec = <span class="built_in">append</span>(vec, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, vec)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(result)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        result[i], result[j] = result[j], result[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历获取二叉树的右视图"><a href="#层序遍历获取二叉树的右视图" class="headerlink" title="层序遍历获取二叉树的右视图"></a>层序遍历获取二叉树的右视图</h2><p><img src="https://img.shields.io/badge/leetcode-199-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightSideView</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    result := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> i == size - <span class="number">1</span> &#123;</span><br><span class="line">                result = <span class="built_in">append</span>(result, node.Val)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历获取二叉树的层平均值"><a href="#层序遍历获取二叉树的层平均值" class="headerlink" title="层序遍历获取二叉树的层平均值"></a>层序遍历获取二叉树的层平均值</h2><p><img src="https://img.shields.io/badge/leetcode-637-blue.svg" alt> <a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">二叉树的层平均值</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">averageOfLevels</span><span class="params">(root *TreeNode)</span> []<span class="title">float64</span></span> &#123;</span><br><span class="line">    result := []<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    queue := list.New()</span><br><span class="line">    queue.PushBack(root)</span><br><span class="line">    <span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := queue.Len()</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue.Front()</span><br><span class="line">            queue.Remove(node)</span><br><span class="line">            t := node.Value.(*TreeNode)</span><br><span class="line">            sum += t.Val</span><br><span class="line">            <span class="keyword">if</span> t.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(t.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> t.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue.PushBack(t.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, <span class="keyword">float64</span>(sum) / <span class="keyword">float64</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历获取N叉树的层序遍历"><a href="#层序遍历获取N叉树的层序遍历" class="headerlink" title="层序遍历获取N叉树的层序遍历"></a>层序遍历获取N叉树的层序遍历</h2><p><img src="https://img.shields.io/badge/leetcode-429-blue.svg" alt> <a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">N叉树的层序遍历</a></p>
<ul>
<li>同二叉树的层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * type Node struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Children []*Node</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *Node)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*Node&#123;&#125;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        vec := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            vec = <span class="built_in">append</span>(vec, node.Val)</span><br><span class="line">            <span class="keyword">for</span> _, n := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">append</span>(result, vec)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序遍历二叉树展开为链表"><a href="#前序遍历二叉树展开为链表" class="headerlink" title="前序遍历二叉树展开为链表"></a>前序遍历二叉树展开为链表</h2><p><img src="https://img.shields.io/badge/leetcode-114-blue.svg" alt> <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    list := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> node != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            list = <span class="built_in">append</span>(list, node)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        node = node.Right</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(list); i++ &#123;</span><br><span class="line">        prev, curr := list[i<span class="number">-1</span>], list[i]</span><br><span class="line">        prev.Left, prev.Right = <span class="literal">nil</span>, curr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-226-blue.svg" alt> <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left, root.Right = root.Right, root.Left</span><br><span class="line">    invertTree(root.Left)</span><br><span class="line">    invertTree(root.Right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack) - <span class="number">1</span>]</span><br><span class="line">        node.Left, node.Right = node.Right, node.Left</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>层序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            node.Left, node.Right = node.Right, node.Left</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-101-blue.svg" alt> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(left *TreeNode, right *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> right != <span class="literal">nil</span> &amp;&amp; left == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> right == <span class="literal">nil</span> &amp;&amp; left != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> right == <span class="literal">nil</span> &amp;&amp; left == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> right.Val != left.Val &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">    outside := compare(left.Left, right.Right)</span><br><span class="line">    inside := compare(left.Right, right.Left)</span><br><span class="line">    <span class="keyword">return</span> outside &amp;&amp; inside</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(root.Left, root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代，队列和栈均可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root.Left)</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        left := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]</span><br><span class="line">        right := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> || left.Val != right.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, left.Left)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, right.Right)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, left.Right)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, right.Left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></p>
<ul>
<li>后序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123; <span class="keyword">return</span> y &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Max(depth(node.Left), depth(node.Right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> depth(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>层序遍历</li>
</ul>
<h2 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a>N叉树的最大深度</h2><p><img src="https://img.shields.io/badge/leetcode-104-blue.svg" alt> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">N叉树的最大深度</a></p>
<ul>
<li>迭代，同二叉树</li>
<li>层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * type Node struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Children []*Node</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *Node)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*Node&#123;&#125;</span><br><span class="line">    depth := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> depth &#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        depth++</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> _, n := <span class="keyword">range</span> node.Children &#123;</span><br><span class="line">                <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">                    queue = <span class="built_in">append</span>(queue, n)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p><img src="https://img.shields.io/badge/leetcode-111-blue.svg" alt> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123; <span class="keyword">return</span> y &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    leftDepth := depth(node.Left)</span><br><span class="line">    rightDepth := depth(node.Right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node.Right == <span class="literal">nil</span> &amp;&amp; node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Min(leftDepth, rightDepth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> depth(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    depth := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> depth &#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        depth++</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全二叉树的节点数"><a href="#完全二叉树的节点数" class="headerlink" title="完全二叉树的节点数"></a>完全二叉树的节点数</h2><p><img src="https://img.shields.io/badge/leetcode-222-blue.svg" alt> <a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">完全二叉树的节点个数</a></p>
<ul>
<li>前序遍历递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nodeNum</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + nodeNum(node.Left) + nodeNum(node.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nodeNum(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>层序遍历迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> count &#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-110-blue.svg" alt> <a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">depth</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    leftDepth := depth(node.Left)</span><br><span class="line">    <span class="keyword">if</span> leftDepth &lt; <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">-1</span> &#125;</span><br><span class="line">    rightDepth := depth(node.Right)</span><br><span class="line">    <span class="keyword">if</span> rightDepth &lt; <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">-1</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> math.Abs(<span class="keyword">float64</span>(leftDepth) - <span class="keyword">float64</span>(rightDepth)) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Max(leftDepth, rightDepth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> depth(root) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><p><img src="https://img.shields.io/badge/leetcode-257-blue.svg" alt> <a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">二叉树的所有路径</a></p>
<ul>
<li>谦虚遍历递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(node *TreeNode, pathStr <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    results := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    pathStr += strconv.Itoa(node.Val)</span><br><span class="line">    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, pathStr)</span><br><span class="line">    &#125;</span><br><span class="line">    pathStr += <span class="string">"-&gt;"</span></span><br><span class="line">    <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, path(node.Left, pathStr)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, path(node.Right, pathStr)...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binaryTreePaths</span><span class="params">(root *TreeNode)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> []<span class="keyword">string</span>&#123;&#125; &#125;</span><br><span class="line">    <span class="keyword">return</span> path(root, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><p><img src="https://img.shields.io/badge/leetcode-100-blue.svg" alt> <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></p>
<ul>
<li>递归，同对称树</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> p.Val != q.Val &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">    left := isSameTree(p.Left, q.Left)</span><br><span class="line">    right := isSameTree(p.Right, q.Right)</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代，队列和栈均可，同对称树</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;&#125;</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, p)</span><br><span class="line">    queue = <span class="built_in">append</span>(queue, q)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        left := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]</span><br><span class="line">        right := queue[<span class="number">0</span>]; queue = queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> || left.Val != right.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, left.Left)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, right.Left)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, left.Right)</span><br><span class="line">        queue = <span class="built_in">append</span>(queue, right.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p><img src="https://img.shields.io/badge/leetcode-404-blue.svg" alt> <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">左叶子之和</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfLeftLeaves</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &amp;&amp; root.Left.Left == <span class="literal">nil</span> &amp;&amp; root.Left.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        sum = root.Left.Val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum + sumOfLeftLeaves(root.Left) + sumOfLeftLeaves(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p><img src="https://img.shields.io/badge/leetcode-513-blue.svg" alt> <a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">找树左下角的值</a></p>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findBottomLeftValue</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    queue := []*TreeNode&#123;root&#125;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        size := <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">            node := queue[<span class="number">0</span>]</span><br><span class="line">            queue = queue[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &#123; result = node.Val &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p><img src="https://img.shields.io/badge/leetcode-112-blue.svg" alt> <a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == targetSum &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    nextSum := targetSum - root.Val</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left, nextSum) || hasPathSum(root.Right, nextSum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h2><p><img src="https://img.shields.io/badge/leetcode-113-blue.svg" alt> <a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和II</a></p>
<ul>
<li>递归，注意Go的引用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>, res *[][]<span class="keyword">int</span>, path[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">    nextSum := targetSum - root.Val</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nextSum == <span class="number">0</span> &#123;</span><br><span class="line">            tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(tmp, path)</span><br><span class="line">            *res = <span class="built_in">append</span>(*res, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        traverse(root.Left, nextSum, res, path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        traverse(root.Right, nextSum, res, path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    path := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> result &#125;</span><br><span class="line">    traverse(root, targetSum, &amp;result, path)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-106-blue.svg" alt> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a></p>
<ul>
<li>先取后序遍历最后一个值作为当前根节点，从中序遍历比对确定左右子树切割位置，后序遍历子树大小应和中序遍历数组子序列一致，将切分出的左右子序列递归。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> TreeBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">    inorder []<span class="keyword">int</span></span><br><span class="line">    postorder []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t TreeBuilder)</span><span class="title">traverse</span><span class="params">(inStart, inEnd, poStart, poEnd <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> poStart == poEnd &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    rootVal := t.postorder[poEnd - <span class="number">1</span>]</span><br><span class="line">    root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line">    <span class="keyword">if</span> poEnd - poStart == <span class="number">1</span> &#123; <span class="keyword">return</span> root &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inMid <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> inMid = inStart; inMid &lt; inEnd; inMid++ &#123;</span><br><span class="line">        <span class="keyword">if</span> t.inorder[inMid] == rootVal &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poMid := poStart + inMid - inStart</span><br><span class="line">    root.Left = t.traverse(inStart, inMid, poStart, poMid)</span><br><span class="line">    root.Right = t.traverse(inMid + <span class="number">1</span>, inEnd, poMid, poEnd - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="keyword">int</span>, postorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TreeBuilder&#123;inorder, postorder&#125;.traverse(<span class="number">0</span>, <span class="built_in">len</span>(inorder), <span class="number">0</span>, <span class="built_in">len</span>(postorder))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从中序与前序遍历序列构造二叉树"><a href="#从中序与前序遍历序列构造二叉树" class="headerlink" title="从中序与前序遍历序列构造二叉树"></a>从中序与前序遍历序列构造二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-105-blue.svg" alt> <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从中序与前序遍历序列构造二叉树</a></p>
<ul>
<li>类似后序+中序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> TreeBuilder <span class="keyword">struct</span> &#123;</span><br><span class="line">    inorder []<span class="keyword">int</span></span><br><span class="line">    preorder []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t TreeBuilder)</span><span class="title">traverse</span><span class="params">(inStart, inEnd, prStart, prEnd <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// fmt.Printf("%v %v | %v %v \n", inStart, inEnd, prStart, prEnd)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> prStart == prEnd &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    rootVal := t.preorder[prStart]</span><br><span class="line">    root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line">    <span class="keyword">if</span> prEnd - prStart == <span class="number">1</span> &#123; <span class="keyword">return</span> root &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inMid <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> inMid = inStart; inMid &lt; inEnd; inMid++ &#123;</span><br><span class="line">        <span class="keyword">if</span> t.inorder[inMid] == rootVal &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prMid := prStart + <span class="number">1</span> + inMid - inStart</span><br><span class="line">    root.Left = t.traverse(inStart, inMid, prStart + <span class="number">1</span>, prMid)</span><br><span class="line">    root.Right = t.traverse(inMid + <span class="number">1</span>, inEnd, prMid, prEnd)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TreeBuilder&#123;inorder, preorder&#125;.traverse(<span class="number">0</span>, <span class="built_in">len</span>(inorder), <span class="number">0</span>, <span class="built_in">len</span>(preorder))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改写成slice更简洁</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// fmt.Printf("%v | %v \n", preorder, inorder)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    rootVal := preorder[<span class="number">0</span>]</span><br><span class="line">    root := &amp;TreeNode&#123;Val: rootVal&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">1</span> &#123; <span class="keyword">return</span> root &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> inMid <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> inMid = <span class="number">0</span>; inMid &lt; <span class="built_in">len</span>(inorder); inMid++ &#123;</span><br><span class="line">        <span class="keyword">if</span> inorder[inMid] == rootVal &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.Left = buildTree(preorder[<span class="number">1</span>:<span class="number">1</span>+inMid], inorder[:inMid])</span><br><span class="line">    root.Right = buildTree(preorder[<span class="number">1</span>+inMid:], inorder[inMid+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-654-blue.svg" alt> <a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">最大二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123; </span><br><span class="line">            max = v</span><br><span class="line">            index = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root := &amp;TreeNode&#123;Val: max&#125;</span><br><span class="line">    root.Left = constructMaximumBinaryTree(nums[:index])</span><br><span class="line">    root.Right = constructMaximumBinaryTree(nums[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p><img src="https://img.shields.io/badge/leetcode-617-blue.svg" alt> <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(root1 *TreeNode, root2 *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root1 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root2 &#125;</span><br><span class="line">    <span class="keyword">if</span> root2 == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root1 &#125;</span><br><span class="line">    root1.Val += root2.Val</span><br><span class="line">    root1.Left = mergeTrees(root1.Left, root2.Left)</span><br><span class="line">    root1.Right = mergeTrees(root1.Right, root2.Right)</span><br><span class="line">    <span class="keyword">return</span> root1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p><img src="https://img.shields.io/badge/leetcode-700-blue.svg" alt> <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的搜索</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; val &#123; <span class="keyword">return</span> searchBST(root.Left, val) &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; val &#123; <span class="keyword">return</span> searchBST(root.Right, val) &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; val &#123; </span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p><img src="https://img.shields.io/badge/leetcode-98-blue.svg" alt> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></p>
<ul>
<li>递归，注意子树区间必须，需要上下界来判断</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(root *TreeNode, lower, upper <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>中序遍历，序列递增</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    valid, _ := traverse(root, math.MinInt64)</span><br><span class="line">    <span class="keyword">return</span> valid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> valid <span class="keyword">bool</span></span><br><span class="line">    valid, val = traverse(root.Left, val)</span><br><span class="line">    <span class="keyword">if</span> !valid &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root.Val &lt;= val &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, val</span><br><span class="line">    &#125;</span><br><span class="line">    val = root.Val</span><br><span class="line"></span><br><span class="line">    valid, val = traverse(root.Right, val)</span><br><span class="line">    <span class="keyword">if</span> !valid &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><p><img src="https://img.shields.io/badge/leetcode-530-blue.svg" alt> <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></p>
<ul>
<li>中序遍历，Go的struct指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Searcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    min <span class="keyword">int</span></span><br><span class="line">    last <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Searcher)</span><span class="title">traverse</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    s.traverse(root.Left)</span><br><span class="line">    val := Abs(root.Val - s.last)</span><br><span class="line">    <span class="keyword">if</span> val &lt; s.min &#123;</span><br><span class="line">        s.min = val</span><br><span class="line">    &#125;</span><br><span class="line">    s.last = root.Val</span><br><span class="line">    s.traverse(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinimumDifference</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    s := Searcher&#123;math.MaxInt64, math.MaxInt64&#125;</span><br><span class="line">    s.traverse(root)</span><br><span class="line">    <span class="keyword">return</span> s.min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p><img src="https://img.shields.io/badge/leetcode-501-blue.svg" alt> <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的众数</a></p>
<ul>
<li>二叉搜索树中序遍历有序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Searcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    Last <span class="keyword">int</span></span><br><span class="line">    Count <span class="keyword">int</span></span><br><span class="line">    MaxCount <span class="keyword">int</span></span><br><span class="line">    Modes []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Searcher)</span><span class="title">traverse</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    s.traverse(root.Left)</span><br><span class="line">    <span class="keyword">if</span> root.Val == s.Last &#123;</span><br><span class="line">        s.Count++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.Last = root.Val</span><br><span class="line">        s.Count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.Count &gt; s.MaxCount &#123;</span><br><span class="line">        s.Modes = <span class="literal">nil</span></span><br><span class="line">        s.Modes = <span class="built_in">append</span>(s.Modes, root.Val)</span><br><span class="line">        s.MaxCount = s.Count</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s.Count == s.MaxCount &#123;</span><br><span class="line">        s.Modes = <span class="built_in">append</span>(s.Modes, root.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    s.traverse(root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    s := Searcher&#123;</span><br><span class="line">        Last: <span class="number">0</span>,</span><br><span class="line">        Count: <span class="number">0</span>,</span><br><span class="line">        MaxCount: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    s.traverse(root)</span><br><span class="line">    <span class="keyword">return</span> s.Modes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><img src="https://img.shields.io/badge/leetcode-236-blue.svg" alt> <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">     <span class="keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;</span><br><span class="line">         <span class="keyword">return</span> root</span><br><span class="line">     &#125;</span><br><span class="line">     left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">     right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">     <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123; <span class="keyword">return</span> root &#125;</span><br><span class="line">     <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right == <span class="literal">nil</span> &#123; <span class="keyword">return</span> left &#125;</span><br><span class="line">     <span class="keyword">if</span> left == <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123; <span class="keyword">return</span> right &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><img src="https://img.shields.io/badge/leetcode-235-blue.svg" alt> <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></p>
<ul>
<li>二叉搜索树有序，前序遍历，第一个落在[p, q]或[q, p]区间的就是公共祖先</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val   int</span></span><br><span class="line"><span class="comment"> *     Left  *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val   int</span></span><br><span class="line"><span class="comment"> *     Left  *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Val &gt; p.Val &amp;&amp; root.Val &gt; q.Val &#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val &lt; p.Val &amp;&amp; root.Val &lt; q.Val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><p><img src="https://img.shields.io/badge/leetcode-701-blue.svg" alt> <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的插入操作</a></p>
<ul>
<li>利用二叉搜索树的性质插入</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;TreeNode&#123;Val: val&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> val &lt; root.Val &#123;</span><br><span class="line">        root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> val &gt; root.Val &#123;</span><br><span class="line">        root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2><p><img src="https://img.shields.io/badge/leetcode-450-blue.svg" alt> <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除二叉搜索树中的节点</a></p>
<ul>
<li>删除节点时分五种情况：<ol>
<li>找不到</li>
<li>左右都为空，直接删除</li>
<li>左空右不空，等于右</li>
<li>右空左不空，等于左</li>
<li>左右都不空，有两种方案<ul>
<li>用右子树中最小的节点替换，退化为2，因为右子树中最小节点也一定比左子树中的任意节点都大，这个节点是右子树的最左叶子节点。可以统一2/3/5。</li>
<li>把左子树挂在右子树的最左叶子节点，退化为3</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(root *TreeNode, key <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val == key &#123;</span><br><span class="line">        <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        cur := root.Right</span><br><span class="line">        <span class="keyword">for</span> cur.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur = cur.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root.Val, cur.Val = cur.Val, root.Val</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left = deleteNode(root.Left, key)</span><br><span class="line">    root.Right = deleteNode(root.Right, key)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p><img src="https://img.shields.io/badge/leetcode-669-blue.svg" alt> <a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">修剪二叉搜索树</a></p>
<ul>
<li>前序遍历，如果节点值小于下界，左子树一定都小于下界，右子树不一定，可以先把右子树替换当前节点，递归判断。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trimBST</span><span class="params">(root *TreeNode, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> root &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.Left, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    root.Left = trimBST(root.Left, low, high)</span><br><span class="line">    root.Right = trimBST(root.Right, low, high)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><p><img src="https://img.shields.io/badge/leetcode-108-blue.svg" alt> <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></p>
<ul>
<li>利用二叉搜索树有序特性，二分数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: nums[mid]&#125;</span><br><span class="line">    root.Left = sortedArrayToBST(nums[:mid])</span><br><span class="line">    root.Right = sortedArrayToBST(nums[mid+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h2><p><img src="https://img.shields.io/badge/leetcode-538-blue.svg" alt> <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></p>
<ul>
<li>反中序遍历累加即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123; <span class="keyword">return</span> val &#125;</span><br><span class="line">    val = traverse(root.Right, val)</span><br><span class="line">    root.Val += val</span><br><span class="line">    val = root.Val</span><br><span class="line">    val = traverse(root.Left, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertBST</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    traverse(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes系统实战 1 - 存储系统</title>
    <url>/k8s/in-action/1-storage-on-k8s/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>云厂商的k8s集群通常提供默认StorageClass，可直接创建磁盘资源。私有k8s集群需要部署存储系统支持PVC的创建。</p>
<a id="more"></a>
<blockquote>
<p>需要<a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">Kubernetes基本知识</a></p>
</blockquote>
<h1 id="本地存储-local-path"><a href="#本地存储-local-path" class="headerlink" title="本地存储 local-path"></a>本地存储 local-path</h1><p>可以用<a href="https://github.com/rancher/local-path-provisioner" target="_blank" rel="noopener">local-path-storage</a>部署基于本地存储的StorageClass。方便灵活，但没有冗余存储，如果Node节点挂掉，相关的PV都会丢失，需要及时备份。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/rancher/local-path-provisioner/blob/master/deploy/local-path-storage.yaml</span><br></pre></td></tr></table></figure>
<h1 id="对象存储-MinIO"><a href="#对象存储-MinIO" class="headerlink" title="对象存储 MinIO"></a>对象存储 MinIO</h1><p>MinIO支持S3，可通过Helm Chart<a href="https://docs.min.io/cn/deploy-minio-on-kubernetes.html" target="_blank" rel="noopener">部署服务</a>。</p>
<p>添加MinIO Repo<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add minio https://helm.min.io/</span><br></pre></td></tr></table></figure></p>
<p>默认部署单节点服务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm install minio/minio</span><br></pre></td></tr></table></figure></p>
<p>分布式服务通过纠删码(EC，Erasure Code)保证高可靠性，需要多节点集群，准备可用的动态存储(longhorn、rook、openebs等)。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm install minio \                                                                        </span><br><span class="line">  --namespace minio --create-namespace \</span><br><span class="line">  --set mode=distributed \</span><br><span class="line">  --set replicas=4 \</span><br><span class="line">  --set persistence.size=10Gi \</span><br><span class="line">  minio/minio</span><br></pre></td></tr></table></figure></p>
<p>可以使用<a href="https://github.com/minio/operator" target="_blank" rel="noopener">MinIO Operator</a>管理租户。</p>
<p>安装<a href="https://docs.minio.io/docs/minio-client-quickstart-guide" target="_blank" rel="noopener">MinIO客户端</a>访问bucket。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://blade-opt.oss-cn-hangzhou.aliyuncs.com/mc</span><br><span class="line">chmod +x mc</span><br></pre></td></tr></table></figure>
<p>Retreive Keys<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MINIO_ACCESS_KEY=$(kubectl get secrets minio -n minio -o jsonpath=&apos;&#123;.data.accesskey&#125;&apos; | base64 --decode &amp;&amp; echo)</span><br><span class="line">export MINIO_SECRET_KEY=$(kubectl get secrets minio -n minio -o jsonpath=&apos;&#123;.data.secretkey&#125;&apos; | base64 --decode &amp;&amp; echo)</span><br></pre></td></tr></table></figure></p>
<p>集群内设置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mc alias set k8s http://minio.minio.svc:9000 $MINIO_ACCESS_KEY $MINIO_SECRET_KEY</span><br></pre></td></tr></table></figure></p>
<p>可通过<code>~/.mc/config.json</code>修改配置，先执行<code>mc config host</code>。</p>
<p>基本操作<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create</span></span><br><span class="line">mc mb k8s/test</span><br><span class="line">echo "Hello MinIO" &gt; /tmp/minio</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> List</span></span><br><span class="line">mc ls k8s</span><br><span class="line">mc ls k8s/test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy</span></span><br><span class="line">mc cp /tmp/minio k8s/test</span><br><span class="line">mc cp k8s/test/minio .</span><br><span class="line">cat minio</span><br><span class="line"><span class="meta">#</span><span class="bash"> Hello MinIO</span></span><br><span class="line">rm minio</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete</span></span><br><span class="line">mc rm k8s/test/minio</span><br><span class="line">mc rb k8s/test</span><br></pre></td></tr></table></figure></p>
<h1 id="分布式文件系统-对象存储-Rook-Ceph"><a href="#分布式文件系统-对象存储-Rook-Ceph" class="headerlink" title="分布式文件系统/对象存储 Rook-Ceph"></a>分布式文件系统/对象存储 Rook-Ceph</h1><blockquote>
<p>需要集群<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md#recommended-mechanism-for-deploying-csi-drivers-on-kubernetes" target="_blank" rel="noopener">配置CSI</a>，如果是云上集群，不要申请FlexVolume。</p>
</blockquote>
<p>Ceph支持分布式块存储、文件系统以及对象存储。机器需要有未分配或未使用的磁盘，至少需要三个节点保持健康。</p>
<p><a href="(https://github.com/rook/rook/blob/master/Documentation/ceph-filesystem.md">安装Cephfs</a>)支持分布式文件系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --single-branch --branch release-1.5 https://github.com/rook/rook</span><br><span class="line">cd rook/cluster/examples/kubernetes/ceph</span><br><span class="line">kubectl apply -f common.yaml</span><br><span class="line">kubectl apply -f crds.yaml</span><br><span class="line">kubectl apply -f operator.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> Wait until operator is running</span></span><br><span class="line">kubectl apply -f cluster.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install Cephfs</span></span><br><span class="line">kubectl apply -f filesystem.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> Install StorageClass rook-cephfs</span></span><br><span class="line">kubectl apply -f csi/cephfs/storageclass.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Mark rook-cephfs as the default storage class</span></span><br><span class="line">kubectl annotate sc rook-cephfs storageclass.kubernetes.io/is-default-class="true"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install toolbox to check status</span></span><br><span class="line">kubectl apply -f toolbox.yaml</span><br><span class="line">kubectl -n rook-ceph exec -it $(kubectl get pods -l=app=rook-ceph-tools -n rook-ceph -o jsonpath='&#123;.items[0].metadata.name&#125;') bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ceph status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ceph -s </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ceph df</span></span><br></pre></td></tr></table></figure>
<p>安装ceph-rgw支持S3对象存储，MinIO Alternative</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f object.yaml</span><br><span class="line">kubectl apply -f object-user.yaml</span><br><span class="line">kubectl get svc rook-ceph-rgw-my-store -n rook-ceph</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Get Bucket Config</span></span><br><span class="line">export AWS_HOST=$(kubectl -n rook-ceph get secret rook-ceph-object-user-my-store-my-user -o jsonpath='&#123;.data.Endpoint&#125;' | base64 --decode)</span><br><span class="line">export AWS_ACCESS_KEY_ID=$(kubectl -n rook-ceph get secret rook-ceph-object-user-my-store-my-user -o jsonpath='&#123;.data.AccessKey&#125;' | base64 --decode)</span><br><span class="line">export AWS_SECRET_ACCESS_KEY=$(kubectl -n rook-ceph get secret rook-ceph-object-user-my-store-my-user -o jsonpath='&#123;.data.SecretKey&#125;' | base64 --decode)</span><br></pre></td></tr></table></figure>
<p>集群内配置好上述环境变量，使用<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="noopener">s3cmd</a>测试bucket读写，可参考<a href="https://zhuanlan.zhihu.com/p/107083375" target="_blank" rel="noopener">文章</a>。可以使用<code>s3cmd --configure</code>详细配置，选择http，不要配置host_bucket。默认域名是<code>rook-ceph-rgw-my-store.rook-ceph.svc</code>(service-name.namespace.svc)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Create</span></span><br><span class="line">s3cmd mb s3://test</span><br><span class="line">echo "Hello Rook" &gt; /tmp/rook</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> List</span></span><br><span class="line">s3cmd ls</span><br><span class="line">s3cmd ls s3://test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Put</span></span><br><span class="line">s3cmd put /tmp/rook s3://test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Get</span></span><br><span class="line">s3cmd get s3://test/rook .</span><br><span class="line">cat rook</span><br><span class="line"><span class="meta">#</span><span class="bash"> Hello Rook</span></span><br><span class="line">rm rook</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete</span></span><br><span class="line">s3cmd rm s3://test/rook</span><br><span class="line">s3cmd rb s3://test</span><br></pre></td></tr></table></figure>
<p>安装ceph-dashboard (Optional)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Either Use HTTP Port 7000</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yq w -i cluster.yaml spec.dashboard.ssl <span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f dashboard-external-http.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Or Use HTTPS Port 8443</span></span><br><span class="line">kubectl apply -f dashboard-external-http.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default Username: admin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default Password:</span></span><br><span class="line">kubectl -n rook-ceph get secret rook-ceph-dashboard-password -o jsonpath="&#123;['data']['password']&#125;" | base64 --decode &amp;&amp; echo</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>消息流在各个应用之间</title>
    <url>/thinking/message-flow/1-current/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>消息是信息传递的最基本单位。</p>
<p>声音，图像，文本，一条消息自身具备独立的语义。</p>
<p>各式各样的应用使用数据库把消息按自己的格式组织起来。</p>
<a id="more"></a>
<h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><blockquote>
<p>备忘录</p>
</blockquote>
<p>大概只会看一次而怕自己忘掉的</p>
<p>很多串文本</p>
<p>记录密码，书名，摘抄，灵感，还想放下图片，文件，音频</p>
<blockquote>
<p>代办事项</p>
</blockquote>
<p>一些早晚忘了更新状态的</p>
<p>一个check复选框 + 一串文本 + 一个定时提醒器</p>
<p>按时间，按位置反复提醒</p>
<blockquote>
<p>收藏夹</p>
</blockquote>
<p>一些你以为你会再用到的</p>
<p>一串文本 + 一串网页链接</p>
<blockquote>
<p>项目计划</p>
</blockquote>
<p>比代办事项复杂一点的甩锅给很多人的</p>
<p>一串文本 + 一些自定义属性</p>
<p>文本之前加上了母女关系，能按树状图排列</p>
<p>可以按自定义属性中的一项按看板排列，通常因为没有大白板和便签纸</p>
<blockquote>
<p>文档</p>
</blockquote>
<p>爷爷是Word</p>
<p>不知道是写给谁看的但至少自己会看一遍的</p>
<p>很多串文本 + 假装表格的文本 + 任何文件链接 + 复杂的页面布局</p>
<p>哦万年不更新所以经常会有坑</p>
<p>可以当成完全展开的专家系统用</p>
<p>文献引用好麻烦</p>
<blockquote>
<p>表格</p>
</blockquote>
<p>爷爷是Excel</p>
<p>看似有无限空间然而只用了左上角的</p>
<p>一张数据表 + 到处填公式的单元格 + 放不下的图表</p>
<p>除了煮咖啡什么都能做</p>
<blockquote>
<p>幻灯片</p>
</blockquote>
<p>爷爷是PowerPoint，大名PPT</p>
<p>把文档的大段文字解释去掉再切成片的</p>
<p>文档 + 从Excel粘来的表格和图表 + 从网上粘来的图片和图标</p>
<p>尺寸可以非常大</p>
<p>还可以加动画，只要我想，全写在一张上也没有问题，导出pdf自带加密</p>
<blockquote>
<p>办公IM</p>
</blockquote>
<p>大部分人都是观众唯一的参与感是收到OK的表情的</p>
<p>无限长 普通文本串 / anything外链</p>
<p>想整合文档，表格，PPT，文件盘，webhook</p>
<p>老板在的群都置顶有新消息就要爬楼看看有没有提到自己</p>
<p>已读不回</p>
<blockquote>
<p>生活IM</p>
</blockquote>
<p>在吗吃啥玩啥到了吗哈哈哈哈哈的</p>
<p>无限长 普通文本串 / 图片(jpg,gif)</p>
<p>经常给自己发文件</p>
<p>大部分群都屏蔽就是不退没事还要去爬楼吃瓜</p>
<blockquote>
<p>笔记应用</p>
</blockquote>
<p>一种不知道为什么特殊的文档</p>
<p>白纸很大无标题前十分钟删除键频率高于50%</p>
<p>迁移超麻烦</p>
<p>算了我还是用markdown放github吧</p>
<blockquote>
<p>数据库</p>
</blockquote>
<p>听起来很难用还要学SQL实际上技术工作大概可能会用到</p>
<blockquote>
<p>调查问卷</p>
</blockquote>
<p>就是Form</p>
<p>一种可以交互的文档</p>
<p>文本 + 按钮 + 各种组件</p>
<p>有一个提交按钮要按</p>
<h1 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h1><blockquote>
<p>文本</p>
</blockquote>
<p>最基本的元素，无处不在</p>
<blockquote>
<p>样式</p>
</blockquote>
<p>包括文本样式，页面布局</p>
<p>可以很灵活，但通常自己选的很丑，不如用系统默认</p>
<blockquote>
<p>数据</p>
</blockquote>
<p>存在数据表里</p>
<p>不用SQL还可以：表格，看板，卡片列表</p>
<blockquote>
<p>链接</p>
</blockquote>
<p>认识的就预览不认识的就留着，包括一切非文本</p>
<blockquote>
<p>控件</p>
</blockquote>
<p>可以和文本各司其职和数据表关联即可</p>
<blockquote>
<p>节奏感</p>
</blockquote>
<p>分割线帮你切出幻灯片</p>
<blockquote>
<p>自动化</p>
</blockquote>
<p>快速复用低代码</p>
]]></content>
      <categories>
        <category>消息流</category>
      </categories>
      <tags>
        <tag>消息流</tag>
      </tags>
  </entry>
  <entry>
    <title>如何掌握复杂事物</title>
    <url>/thinking/misc/complexity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>理论往往是优雅简洁的，但是现实一定是复杂的。为了解决现实问题的理论通常会愈发复杂，解决方案可能会最终超越复杂，变成混乱。</p>
<a id="more"></a>
<h1 id="定性"><a href="#定性" class="headerlink" title="定性"></a>定性</h1><p>究竟该怎么定义<strong>复杂</strong>？<br>复杂在不同人看来可能很不相同。  </p>
<p>正在背诵乘法口诀的小学生可能觉得复杂，正在理解理论物理公式的大学生也可能觉得复杂；<br>正在计算购物节满减凑单优惠的剁手党可能觉得复杂，正在试图理解经手多人外包的代码的程序员可能觉得复杂。<br>大学生看小学生的乘法口诀觉得小菜一碟，而程序员可能不一定能理解满减规则。<br>由此看来，复杂性是由概念数量决定的，需要同时考虑的概念数量越多，就会感觉到越复杂。<br>并且，复杂性与一个人的知识积累以及抽象能力相关，小学生背诵乘法表需要记忆。</p>
<p>我们面对如毛线团般的事物无从下手，而经验丰富的专家则能抽丝剥茧，重新梳理编织得井井有条。<br>那么我们与专家的区别在哪里呢？<br>答案就在<strong>知识储备</strong>上。  </p>
<p>知识储备的一种理解是，如果把我们的思维比作工具箱，把碰到的问题比作奇形怪状的钉子，那么我们的工具箱中有多少种可选的锤子可以帮助我们敲钉子，就代表我们的知识储备的丰富程度。<br>同样是看到一粒凸起的钉子，普通人（未经过专业训练的人）只会觉得无从下手，光是想象自己赤手空拳跟钉子软碰硬时，就觉得疼得要命。而专家可能会掏出他惯用的锤子，敲敲打打，即使不能把钉子敲好，至少手中有锤，心里不慌。<br>反映到现实中来，普通人如果看到一件事的发生，可能不知从何理解，甚至陷入对复杂性的恐慌之中，大脑一片空白。不过普通人绝不止这一种反应，比如还可能回忆起自己一知半解、道听途说来的概念，强行编造个因果关系。<br>如果我们能把现实简化，抽象出概念，建立模型，则能帮我们更好的理解事情，从而找到可能的解决方法。<br><!-- 我们提出了地球公转的模型，并且通过推算预测解释了很多现象，而观测反过来验证了这个模型的正确性，现代人掌握了这个知识，也就不会再像古代人那样，为日食恐慌了。 --></p>
<p>值得注意的是，工具箱思维也只是对知识储备的一种片面解释，如果眼里尽是钉子，那不得跟肉中刺一样疼吗？。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>神经生物学揭示了大脑复杂的物理结构，我们目前很难自底向上地完全解释大脑的运作方式，不过我们在不同层次上建立了几种解释模型。<br>一种是基于信号测量的脑区划分方法（需要准确名称），这种方法通过实验测量大脑不同区域的活跃程度与行为之间的关系。<br>另一种是更抽象的概念模型，用行为来验证模型的适用范围。</p>
<p>认知心理学中就有一个“工作记忆”的模型。模型由长期记忆和短期记忆构成，工作记忆属于短期记忆的一种，相当于思考的工作台，而长期记忆相当于记忆的仓库，用于存储暂时用不到，但可能日后还有用的记忆。<br>每个人的工作记忆大小不同，每个概念占用一定的空间，如果概念数量太多以至于超过了工作台的最大容限，思考将变得困难。<br>我们可以把外界中的概念与工作记忆“交换”，比如用纸或者白板写下来，但因为高速的“内存”和低速的“外存”直接需要不断交换信息，思考的速度将下降。  </p>
<p>另一个模型是关于<strong>快慢系统</strong>的：我们的大脑可以简化成两种思考系统，一种是<strong>系统1</strong>，通常是迅速的，潜意识的，反射式的，不由自主的；另一种是<strong>系统2</strong>，通常是缓慢的，费力的，需要意识参与的，可以控制的。<br>涉及的所谓“肌肉记忆”的技能，以及需要快速反应的“机械知识”都可以通过反复练习固化下来，直接经由系统1做出反应。而学习、分析、推理、想象等行为则需要<strong>系统2</strong>参与，这时影响思考效率的就包括同时处理的概念数量了。</p>
<p>我们感受到的复杂通常是系统2的产物，我们不会觉得辨认普通地辨认猫或者其他常见动物是件复杂的事。<br>这通常在一瞬间发生，当你看到一只典型的“猫”样的物体时，猫这个概念几乎不可阻挡的进入脑中，这也是系统1的特性，它是基于神经系统的。<br>至于接下来的处理步骤就取决于你当时的状态，如果你的注意力集中在别的事情上，那么这个概念也只会转瞬即逝，几乎不会有机会进入长期记忆。<br>如果你需要仔细辨认猫的种类，或者确认那个“猫”样的物体究竟是不是猫时，则<strong>可能</strong>需要系统2的参与。<br>如果你对猫的特征有过深入研究，并且熟悉它们，那么同样猫的品种就已经在系统1的自动处理流水线中处理完成提交到你的脑子里了。<br>而如果你刚刚开始学习辨认猫的品种，捧着一本手册努力查阅或者听一旁的朋友涛涛不觉地解释，就很有可能感受到<strong>复杂</strong>，并且经历被信息淹没的感觉。<br>对于你而言，那些非常细节的概念之间毫无联系，光是努力维持那些概念在脑子里就十分费力了，然而实际上那些概念刚从系统1的视觉或者听觉提交上来没多久，就直接被丢弃了。  </p>
<p>你得承认，复杂超过一定程度，人就几乎不能理解了。  </p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>我们利用了几种模型来帮助我们分析如何处理复杂性这个问题，这些并不是唯一的解释方法。不过这些模型对于我们的提出解决方法已经有足够的启发了。  </p>
<p>根据我们的模型，我们该如何提高处理复杂的能力呢？缩减工作记忆中的概念数量以减少甚至避免和“外界存储”的交换，提高工作记忆的容量以容纳更多的概念数量。</p>
<p>那么如何缩减概念数量呢？我们可以对概念进行分类、抽象、归纳、封装、近似、封装。  </p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>物以类聚，我们可以把相似的概念分为一类——具有共同特征，或者在时空上接近。这样，我们只需按类别考虑概念。<br>许多苹果、梨、香蕉、西瓜、西红柿、黄瓜、冬瓜、南瓜混在一起。如果我们分别考虑每一个物体，由于物体数量很多，就很难同时考虑。如果我们先按品种先分类，就只需要考虑8堆果蔬，一共8个概念。进一步，我们再按能不能带皮吃分类，则只需要考虑2种概念：能带皮吃和不能带皮的。在此基础上讨论理解，则比同时考虑多个具体概念容易得多。<br>当然分类的方法不止一种，比如按颜色分类、按大小分类，分类的具体原则要根据具体问题决定。适应问题的合理分类，能帮助我们更好的简化模型，梳理思路。   </p>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是指把多种概念的共同特征提取出来，从具体的事物体中抽象出概念。比如考虑上面提到的果蔬混合物，在分类的基础上，我们可以提取出水果和蔬菜的概念，这样就能在一般性地研究水果或者蔬菜的特性。<br>有时候，抽象所提取的共同特征太少，导致可以被归类的概念太多、太宽泛，这种抽象可能不一定适合我们想要考虑的问题。我们可以多层抽象，比如将共同特征的要求放严一些，这样抽象得到的概念类别也就更多并且具体些。<br>合理的抽象层次，对模型的组织方式有很大影响。   </p>
<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p>苹果是甜的，梨也是甜的，西瓜是水果，那么西瓜是甜的吗？我们可以从苹果和梨的特性上尝试归纳出水果是甜的这个特征，以此为假设前提，并通过演绎推广到同样是水果的西瓜上，可以得出西瓜也是甜的的结论。这就是<strong>归纳-演绎</strong>的常见用法。<br>不过，要小心掉进逻辑的陷阱！归纳-演绎的结构推导出的结论正确，必须建立在归纳的结论正确之上，归纳的结论正确又必须建立在引用事实的正确之上。<br>有的人把假设当事实，自然会归纳得出荒谬的结论；有的人不看具体场景，只觉得要解决的问题与归纳的模式有几分相似便套用模板，自然错到离谱，在考试上俗称套公式。  </p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是将复杂而紧密联系的概念当成一个整体，也就是当成所谓的<strong>黑盒</strong>，在考虑更高层次的问题时，仅考虑这个整体与外界的互动，而不必关心它的内部细节。<br>黑盒的概念应用很广。在研究大脑和行为的关系时，就有人通过人接受的刺激和做出的行为来为黑盒建立模型，这种模型是概念上的。在生活上，我们经常也不自觉结合“常识”的给身边的“黑盒”建立模型，比如在炎炎夏日我们进入室内打开空调时，可能会把空调调到最低温度，而不是最适宜温度，这里就隐含了一个我们给空调这个黑盒建立的模型——设定的温度与当前温度温差越大，空调工作的功率越高，然而这不是空调的真实模型。<br>因此，封装并使用简化的黑盒可以缩减概念数量，但是要注意简化后的模型能在多大程度上还原之前的解释，是否符合需要。</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>有时候，许多概念一拥而上，着实令人头疼。但在开始分析之前，先判断是不是这么多概念都是需要同时思考的，是不是可以<strong>分而治之</strong>。<br>分而治之的思想自古有之，如果我们面对大问题难以入手，那么就化整为零，再逐个击破。同样，面对繁多的概念，如果他们可以分解成更小的概念组，再分别考虑，那么一次要处理的概念数量就能减少不少。  </p>
<h2 id="近似"><a href="#近似" class="headerlink" title="近似"></a>近似</h2><p>近似用哲学的话来说就是：抓住主要矛盾。<br>近似在工程上经常使用。比如我们通过公式推导出了一串复杂的解，我们通常会在误差允许的范围内对解做近似，忽略权重低的项，保留权重高的项。在简化了解的同时在很大程度上保证结论的有效性，并且这让我们能对更有影响力的变量给予更多的注意力。放在实际应用中，我们就能集中资源攻克主要问题。<br>同样，需要注意的是，不要忘记模型的公式本身是对现实的近似，答案本身是对精确解的解释，而如果使用计算机求解，同样要面对有效数字的近似问题。现实在层层近似之后通过仿真展示在我们面前，然而仿真不是真，也不是现实。<br>化简概念也是类似，把细枝末节剔除出去后，剩下重要的概念也应该不会太多。</p>
<p>关于如何扩容，工作记忆这个模型对应着物理的神经系统，想要扩容十分困难。有许多号称可以提高记忆力的方法，其实是也通过减少概念数量。比如，通过谐音的方法将需要记忆的概念连成一个故事或者组成一幅画面，概念之间不再毫无关联，而是形成了一个可以自动播放的整体，回忆时再通过机械记忆住的映射规则（回忆一下小时候背乘法口诀表或者中学背元素周期表）反向解释即可。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>以编程为例，开始学习时，我们更注意程序语言的语法，通过一些简单的例子体会语言的特性。这时语法上的每一个特征对我们来说都是一个独立的概念，我们需要不断回顾语法规则来加载概念到工作记忆。此时十分费力，也就是入门的阶段。<br>我们在从外界反复使用这些新概念的同时，我们的大脑会根据“重复=重要”的原则把这些概念放入长期记忆中，并且通过反复练习提高熟练度可以提高概念从长期记忆中提取的速度。  </p>
<p>在反复练习之中，我们会发现不必过于关注语法本身，而可以总结出基本的使用模式。<br>我们可以抽象出控制结构、循环结构这样的基本结构，明白了可以使用函数来把一系列紧密相关的实现封装起来。我们在阅读别人的代码时，可以不必关注实现细节，而是通过主要函数的调用关系理解整个模块的功能。<br>在这种自底向上的抽象过程中，可能会引入新的编程模型，新的功能模块，新的独立系统。  </p>
<p>得益于此，我们可以在高抽象层次上设计系统。我们有能力把握有限的子系统数量，如果子系统的数量过多，可以进一步抽象，保持整体的概念数量可控。  </p>
<!-- # 记忆

机械知识的记忆有无必要。

背珠心算的口诀，与培养分析问题的能力，哪个更重要？ -->
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速入门新领域</title>
    <url>/thinking/misc/something-new/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>从零开始学前端（移动端）的过程记录，以及走神想到的关于学习新领域的思考。</p>
</blockquote>
<a id="more"></a>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>互联网上的垃圾越来越多，各个大厂的生态也趋于闭合。即使仍然还有人在免费提供优质的内容，Google的爬虫也无能为力。<br>现在大行其道的推荐算法，它或许可以通过我的注意力停留时长判断出我的兴趣所在，但在一人一票的制度下，很难为我们挖掘真正沉淀了价值的东西。<br>信息就像一次性纸巾，在被人擦过鼻涕后便只能扔掉，而在一些激励的鼓励下，有不少人在全天无休的制造着这些白色垃圾。  </p>
<p>这是我最初开始设想阡陌时的一个初衷：<strong>发掘高质量、长生命期的内容</strong>。</p>
<p>具体的设想暂且不展开，打造一片理想的数字世界需要技术的支持，而作为数字世界大门的就是前端。</p>
<p>我之前对于前端的了解很少，大概觉得网页就是前端。不过，在各行各业，“前端”都有所知，我之前做硬件开发时的前端便是Verilog HDL。<br>虽然对前端不太了解，但是我觉得计算机软件开发技术可能是所有应用技术里最适合自学入门的，不仅网上现成免费的书籍、课程多，而且得益于开源的兴起，实战项目也不少。  </p>
<p>不过这些资源散落在互联网的汪洋大海中，并且其中有一大部分处于公海之外的私人水域中。除此之外，资源的质量如何，难度是否合适，应该何时使用，却少有说明。<br>为数不多的路线地图（Roadmap）也只是笼统而论，还没入门的小白用户看起来自然也就一头雾水，等到七拼八凑，走过了不少弯路，才懵懵懂懂有了些印象。<br>这些是我个人在学习过程中的体会，姑且先推广开来，假设和我有相似遭遇的大有人在吧。</p>
<p>据此至少可以提出三个需求：   </p>
<ul>
<li>第一，我希望有一份详细的路线地图，可以让我对需要学习的领域形成大致的“方向感”；  </li>
<li>第二，我希望路线地图拆分成里程碑（Milestone），把一个大目标拆分成小目标，逐个击破，在及时反馈之中增强信心；  </li>
<li>第三，我希望学习之路上，有人通行，亦师亦友，汇总常见问题，甚至可以做成专家系统，节约入门者和指导者的时间。  </li>
</ul>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>首先，分析我的位置：</p>
<ul>
<li>掌握Python、C++等编程语言。</li>
<li>了解计算机网络基本常识。</li>
<li>熟悉搜索引擎的使用方法🤣。</li>
</ul>
<p>其次，权衡我的目标：</p>
<p><strong>网页端、移动端还是桌面端？</strong></p>
<p>这其实是在考虑这三种平台优势是什么。  </p>
<ul>
<li>网页端适合电脑使用，对实时性要求不高，合适生产力模式下使用。 </li>
<li>移动端便携性好，普及程度广，合适随身模式使用，但可能被娱乐模式干扰，优先级较高。  </li>
<li>桌面端适合电脑使用，有更强的性能与定制性。</li>
</ul>
<p><strong>现有主流框架有哪些？是否有跨平台框架？</strong></p>
<p>网页端有React、Angular、Vue，移动端有Android/iOS原生，桌面端各个系统各式各样。跨平台的方案有React Native、Electron、Flutter。</p>
<p><strong>各个框架的优势是什么？</strong> </p>
<p>对比主要从代码复用性和社区成熟度上考虑。代码复用性包括跨平台代码复用，可用第三方库。社区成熟度包括文档、教程的完善程度，项目活跃度，是否仍在积极维护。<br>框架的选择也是见仁见智，JS框架在性能上可能不如意，移动原生开发需要的学习量和工作量太过巨大，跨平台方案不太成熟。评估之后还是选择移动端切入，日后可以补充JS框架做网页端。</p>
<p>这里的问题是，我从网上获得的评论都具有主观性，对前端几乎为0的了解也导致我没办法做出合理判断。再者，<strong>技术只是实现目标的手段</strong>。总之，先淌一淌这浑水再做决定。</p>
<h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><p>学习因目标不同，知识类型不同，有许多不同的方法，从大的方向上可以分为三个阶段。</p>
<p><strong>直接上手</strong>：  </p>
<p>这适合早期入门。在老师的指导下或参考有效的资料，形成对知识的感性认识。常见的学习模式是：你不要问那么多为什么，照做就是。很多时候，通过这种方法，就能大致看懂别人的成果并简单应用了。并且，通过上手-反馈循环，可以积累信心。虽然大多数知识的入门都可以使用这个方法，但通过这个方法学到的知识不系统，存在逻辑缺失，在学习的时候可能会在心里存下不少疑问。比如在出现复杂问题时，可能无法解释，只能诉诸玄学。这就是缺乏系统化、整体化的认知的结果。</p>
<p><strong>系统学习</strong>：  </p>
<p>这适合中期进阶。之所以能系统学习，是因为知识体系相对稳定，有大量前人总结的体系模型可以参考。系统化学习通常来说要明确学习领域和起点，预先给出公理或者假设，在大家都明确了以下所有内容均基于以上公理或者假设——也就是明确了知识体系的适用范围之后，开始引出推论和模型，并且通过严格的逻辑证明推论成立，或者通过模型解释实际案例表示模型有效。经过系统学习，基本上能对大部分问题套用模型分析解释，解决问题，达成目标，有了更强的定制能力。在系统学习的过程中，可以解释之前遇到的不少疑惑，但系统学习需要警惕绝对知识论，需要明确知识是在一定假设上的理想模型，并不是绝对真理。如果批判性地思考学习，心中的疑问可能只增不减，但这并不是一件完全的坏事，这说明对知识有了更全面深刻的认识。所谓知道的越多，才发现不知道得更多。在系统学习过程中，有人不能接受完全接受模型，而是会对为什么提出模型产生疑问，因为知识体系是经过无数人试错后的总结，而了解知识诞生的历史会让我们学习知识的逻辑更加顺畅，因为建立知识体系的历史是探索与偶然的历史。系统学习并不是学习的终点，已知的模型在面对新的问题的时候很可能会失效，这时候就需要科学探究。</p>
<p><strong>科学探究</strong>：  </p>
<p>这适合后期探索。之所以带上科学二字，是因为需要使用科学研究方法，并且得出的知识模型可证伪。不可证伪的知识通常是万能解释的，比如很多伪心理学总能用一套看似有道理的解释套用到所有情况上，并且没法提出切实可行、可重复的解决方案。使用这种方法需要具备丰富的想象力和严谨的逻辑。丰富的想象力要求有能力补足未知的细节，建立知识模型，并设计证明方法，对结果有预期。严谨的逻辑需要知识模型具有可解释性，以前人已有的知识或者可理解的假设作为起点，构建一条完整的逻辑链路。科学探究能构建理论解释之前的一部分疑问，但却有可能调入疑问的黑洞之中，不能说科学的尽头是神学，但是面对自然，仍然要抱有敬畏之心。虽然我们有了一些用来抵御未知的知识，但也要意识到我们这片知识空间的狭小和脆弱，在它之外的是漫无边际、比黑更黑的未知。</p>
<p>希望以上这些可能对处于不同学习阶段的人有点启发，当然这并不是说所有的学习过程都要以第<strong>科学探究</strong>为最终目标，需要根据自己的实际的目标和所处的位置选择合适的方法。比如纯粹建立在逻辑上的知识可能就不能<strong>直接上手</strong>，只能<strong>系统学习</strong>了。又比如应用性强的知识适合直接上手，即所谓自学成才，可能身经百战，但不知其然，但也可以系统学习，即所谓科班出身，可能头头是道，但纸上谈兵。  </p>
<p>值得警惕的是那些打着科学旗号兜售自己的“万灵药”的人。</p>
<p>回到前端入门上来，因为是应用性很强的知识，所以我选择直接上手，需要深度定制或者遇到难解的问题，再回头补习。</p>
<h1 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h1><p>搜了些路线图，有些前人的路可以参考，但完全照搬可能有些拘束，根据自身情况借鉴即可。</p>
<p><strong>第一步</strong>：环境准备。这是几乎学习新编程语言必备的，不同教程大同小异，如果社区成熟，按照文档做一遍就行。一些特殊的网络问题，需要想办法解决，同样成熟的社区也会有相应的解决方案。</p>
<p><strong>第二步</strong>：玩具教程，这通常也是出现在社区文档中的。玩具，又称小玩意儿，通过这些简单的小玩意儿，能大概有个端到端的成果可以展示了。可不要到此就说自己精通了哦。<br>关于语法什么的，如果有相关的编程基础（概念都是相通的，语法存在差异），大概也能猜个大差不差，如果只知道面向对象，而学习函数式可能理解起来就有点费劲，不妨从基础概念开始理解。</p>
<p><strong>第三步</strong>：了解常用组件，通过但不限于高质量的知识沉淀网站，风靡全球的代码托管网站获得基本了解，如果能找到好的起步教程就很好。一个理想的教程符合直接上手的原则，在上手过程中，介绍了常用的组件、使用方式，也就是“套路”。如果这一步有概念缺失，需要自行回溯学习前置知识，只需要回溯到连蒙带猜理解个大差不差的程度就可以回来继续教程了。</p>
<p><strong>第四步</strong>：好了，你已经知道了1+1=2，下面我们来算个不定积分。这是不少人可能遇到的情况，教程也能看了七七八八，却发现离自己想实现的目标还有不小的差距。<br>这个差距通常是几方面方面引起的：不知道某项功能怎么实现，需要定制第三方库，需要自己完全实现。</p>
<p>我们需要逐个击破：</p>
<ul>
<li>不知道用什么轮子：搜索学习更复杂的教程，最好包含自己想实现的功能，或者其中一部分。</li>
<li>有轮子但需要调整：回溯学习第三方库相关知识，尝试修改并观察结果，理解基本原理直到可以上手修改。</li>
<li>找不到轮子：回溯学习所需的知识，自底向上，逐步搭建。</li>
</ul>
<p>其实到这一步，也算淌了些水，我们可以先停一停，需要回到<strong>评估</strong>这一步。如果轮子缺失严重——这通常意味着社区还不够成熟以及巨大的工作量，可能需要考虑使用别的方案，这很有可能意味着<strong>评估</strong>阶段的工作不足，或者领域太新。如果重新评估后发现其他方案更完善，那么应该切换方案。可能有人会抱怨以上四步白白浪费了时间，其实可以从两方面来考虑。其一，这四步消耗的时间是沉没成本，没办法收回，最合理的做法是忽视它，评估继续这个方案所需要的投入以及其他方案从0开始的投入哪个更多。其二，面对一个问题的多种解决方案，通常在回溯之后的知识上是相通的、可重用的，时间也不是完全浪费的。</p>
<p>我学到这里，基本上达到了可以使用轮子搭建自己想要的功能的地步。向后就需要根据设计的功能反复使用第四步的三个方法，直到满足我们的设计，或者修改设计降低实现复杂度。</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>我在这篇文章里，没有重点讲具体的知识点，而是想通过这次的学习实践归纳一般的方法。当然，抽象得足够高的规律都可能变成“万灵药”的危险。</p>
<p>前端先学了一点皮毛，先暂且用着，还要补些网页前端、后端、设计、认知科学方面的知识。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>烤面筋 - 算法</title>
    <url>/work/interview/algo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机算法</p>
<a id="more"></a>
<ul>
<li>找第K大数</li>
<li>捡石头</li>
<li>100盏灯</li>
<li>红黑树</li>
<li>AVL树</li>
<li>N个数取M个</li>
<li>两数之和</li>
</ul>
<p>哈希法</p>
<p>双指针法：<br><a href="https://segmentfault.com/a/1190000023552474" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023552474</a></p>
<ul>
<li>不增加额外空间旋转方阵</li>
<li>递归大树乘法</li>
<li>拿苹果图论，顺序限制</li>
<li>二分排序</li>
<li>str归属集合</li>
<li>数字大序数减去小序数的最大值</li>
<li>N个人围圈报数，求顺序</li>
<li>abcd*4=dcba</li>
<li>33.搜索旋转排序数组</li>
<li>dp，n个物品，每个基础价值ai，第k个拿会减去（k-1）*bi的价值，要拿m个使总价值最大（卡了，面试官给了提示过了</li>
</ul>
<p>背包容量为n，价值a[i]，第k个拿价值减(k - i) * b[i]，物品重量为1<br>dp为第k个拿物品时的最大价值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, m + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(items); i++ &#123;</span><br><span class="line">  <span class="keyword">for</span> j := m; j &gt;= i; i-- &#123;</span><br><span class="line">    dp[j] = max(dp[j], dp[j - <span class="number">1</span>] + a[i] - i * b[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m]</span><br></pre></td></tr></table></figure>
<ul>
<li>贪心，n个怪物，每个怪物有攻击ai，勇者防御初始为d，每打一只防御+1，防御&lt;ai的话直接受到bi的伤害。问最优打怪顺序。（没做出来，给了个n=1000的网络流做法，面试官表示n是10w也能贪心做</li>
</ul>
<p>如果有能不吃伤害打的，直接打<br>如果没有能不吃伤害打的，直接打破防最强的</p>
<ul>
<li>二叉树序列化和反序列化+校验</li>
</ul>
<p>BFS，层序遍历重建二叉树</p>
]]></content>
      <categories>
        <category>面筋</category>
      </categories>
      <tags>
        <tag>面筋</tag>
      </tags>
  </entry>
  <entry>
    <title>烤面筋 - 原理</title>
    <url>/work/interview/cs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机常识，操作系统，编程</p>
<a id="more"></a>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>进程与线程</li>
<li>协程</li>
<li>用户态与内核态</li>
</ul>
<p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
<p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 — 用户态和内核态。</p>
<p>系统调用，陷阱指令</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>HashMap,Guava cache</p>
<p><a href="https://colobu.com/2019/11/18/how-is-the-bigcache-is-fast/" target="_blank" rel="noopener">https://colobu.com/2019/11/18/how-is-the-bigcache-is-fast/</a></p>
<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><ul>
<li>多线程写稀疏矩阵*稠密矩阵</li>
</ul>
<p><a href="https://www.licc.tech/article?id=63" target="_blank" rel="noopener">https://www.licc.tech/article?id=63</a><br>在Eigen中实现稀疏矩阵的多线程乘法</p>
<h1 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h1><ul>
<li>nginx</li>
<li>Redis</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li>关系型数据库存储结构</li>
<li>索引原理</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul>
<li>MQ</li>
</ul>
]]></content>
      <categories>
        <category>面筋</category>
      </categories>
      <tags>
        <tag>面筋</tag>
      </tags>
  </entry>
  <entry>
    <title>烤面筋 - 通用</title>
    <url>/work/interview/general/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数学，智力题</p>
<a id="more"></a>
<ul>
<li>从概率角度，5局3胜和3局2胜，哪个胜算更大？</li>
</ul>
<p>局数越多对高水平的越有利。</p>
<ul>
<li>给定一枚不均匀硬币，抛出正面的概率为P，求抛2K+1至多有K次出现正面的概率</li>
</ul>
]]></content>
      <categories>
        <category>面筋</category>
      </categories>
      <tags>
        <tag>面筋</tag>
      </tags>
  </entry>
  <entry>
    <title>烤面筋 - AI</title>
    <url>/work/interview/recommender/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>机器学习，推荐系统</p>
<a id="more"></a>
<p>百面机器学习算法工程师带你去面试</p>
<p><a href="https://github.com/stormstone/awesome-material/blob/master/Book/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%A6%E4%BD%A0%E5%8E%BB%E9%9D%A2%E8%AF%95.pdf" target="_blank" rel="noopener">https://github.com/stormstone/awesome-material/blob/master/Book/%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%A6%E4%BD%A0%E5%8E%BB%E9%9D%A2%E8%AF%95.pdf</a></p>
<ul>
<li>推荐系统中的三个要素</li>
</ul>
<p>三要素指的是挖掘用户兴趣的信息源。</p>
<p>用户特征：年龄（如新闻，视频推荐 不同年龄的人关注内容不一样），职业（职业不同，关注内容也不一样），地域，性别等。这些我们都可以统称为用户的画像特征。这些用户画像中特征的变化性有不同的特点：如年龄是逐年稳定增加，职业（因人而变，有的长久不变，有的经常变化），性别（基本不变），地域（也会变化）。</p>
<p>商品特征：类型（车，手机，体育新闻，娱乐新闻等），商品内容（车的品牌，颜色，大小；手机的品牌，智能程序；足球新闻，篮球新闻；某明星娱乐新闻；歌曲的演唱者等），商品展示的位置（置顶，边框，角落），展示的方式等。这些我们称为商品特征</p>
<p>行为（用户对商品的行为 ）特征：购买。长时间阅读某新闻；点击某广告并快速关闭或长时间停留；完事听完某歌 曲并短时间内重复听。这些特征称为用户对商品行为特征，简称行为特征。</p>
<ul>
<li>请设计一个你认为能够处理百万日活的推荐系统框架？（包括算法和工程落地方案）</li>
<li>之前做的推荐系统可以达到实时吗？你认为怎样的推荐系统能够达到实时？（日活百万）</li>
<li>给出一个标准三层结构（召回，粗排，过滤），每个结构上有10个待上线算法，日活百万，如何解决每个算法上训练时数据量不足的问题？（提示：用流量正交）</li>
<li>对于在线端，近线端和离线端的理解？</li>
<li>实时推荐系统三大模块中，最快达到性能瓶颈的是哪一个模块？为什么？怎么解决？</li>
<li>现在让你设计一个日活百万的推荐系统架构，请从在线端和离线端两个角度描述你的设计方案</li>
<li>如何设计A/B Test系统？如何保证流量正交？</li>
<li>流量分桶吗？如何保证流量分桶唯一？</li>
</ul>
<h2 id="树模型"><a href="#树模型" class="headerlink" title="树模型"></a>树模型</h2><ul>
<li>GBDT 的原理（知识）</li>
<li>决策树节点分裂时是如何选择特征的？（知识）</li>
<li>写出 Gini Index 和 Information Gain 的公式并举例说明（知识）</li>
<li>分类树和回归树的区别是什么？（知识）</li>
<li>与 Random Forest 作比较，并以此介绍什么是模型的Bias和Variance（知识）</li>
<li>XGBoost 的参数调优有哪些经验（工具）</li>
<li>XGBoost 的正则化是如何实现的（工具）</li>
<li>XGBoost 的并行化部分是如何实现的（工具）</li>
<li>为什么预测股票涨跌一般都会出现严重的过拟合现象（业务）</li>
<li>如果选用一种其他的模型替代 XGBoost 或者改进 XGBoost 你会怎么做，为什么？（业务+逻辑+知识）</li>
</ul>
<h2 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h2><ul>
<li>softmax 函数的定义是什么？（知识）</li>
<li>深度神经网络为什么会产生梯度消失现象，如何解决它？（知识）</li>
<li>常见的激活函数有哪些？都有什么特点？（知识）</li>
<li>挑一种激活函数推导梯度下降的过程。（知识+逻辑）</li>
<li>Attention 机制什么？（知识）</li>
<li>阿里将attention机制引入推荐模型的动机是什么？（知识+业务）</li>
<li>DIN中将用户和商品进行了embedding，请讲清楚两项你知道的embedding 方法。（知识）</li>
<li>推荐系统中 embedding 技术都可以有哪些应用？（业务+知识）</li>
<li>你如何 serving 类似 DIN 这样的深度学习模型(工具+业务)</li>
</ul>
<h2 id="广度"><a href="#广度" class="headerlink" title="广度"></a>广度</h2><ul>
<li>NN，RNN，个别聚类算法，模型评估等知识的理解程度</li>
<li>spark的调优经验，model serving的主要方法，parameter server的原理</li>
<li>GAN，LSTM，online learning的基本理解</li>
<li>embedding方法，attention机制，multi task，GNN，reinforcement learning，online learning的基本理解</li>
</ul>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><ul>
<li>为什么需要对数值型特征做归一化呢？</li>
</ul>
<p>保持相同学习速率下，特征的更新速度一致，梯度下降更快。当然，数据归一化并不是万能的。在实际应用中，通过梯度下降法求解的模型通常是需要归一化的，包括线性回归、逻辑回归、支持向量机、神经网络等模型。但对于决策树模型则并不适用，以C4.5为例，决策树在进行节点分裂时主要依据数据集D关于特征x的信息增益比（详见第3章第3节），而信息增益比跟特征是否经过归一化是无关的，因为归一化并不会改变样本在特征x上的信息增益。</p>
<ul>
<li>什么时候需要对连续特征分桶？</li>
</ul>
<p><a href="https://cloud.tencent.com/developer/article/1590912" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1590912</a><br>分桶是离散化的常用方法，将连续型特征离线化为一系列 0/1 的离散特征；<br>当数值特征跨越不同的数量级的时候，模型可能会只对大的特征值敏感，这种情况可以考虑分桶操作。<br>分桶操作可以看作是对数值变量的离散化，之后通过二值化进行 one-hot 编码。<br>分桶的数量和宽度可以根据业务领域的经验来指定，但也有一些常规的做法：</p>
<ol>
<li>等距分桶。每个桶的宽度是固定的，即值域范围是固定的，比如是 0-99，100-199，200-299等；这种适合样本分布比较均匀的情况，避免出现有的桶的数量很少，而有的桶数量过多的情况；</li>
<li>等频分桶，也称为分位数分桶。也就是每个桶有一样多的样本，但可能出现数值相差太大的样本放在同个桶的情况；<br>模型分桶。使用模型找到最佳分桶，比如聚类，将特征分成多个类别，或者树模型，这种非线性模型天生具有对连续型特征切分的能力，利用特征分割点进行离散化。</li>
</ol>
<p>分桶的优点：</p>
<ol>
<li>分桶后得到的稀疏向量，内积乘法运算速度更快，计算结果更方便存储；</li>
<li>对异常数据有很强的鲁棒性</li>
</ol>
<ul>
<li>在对数据进行预处理时，应该怎样处理类别型特征？</li>
</ul>
<p>大小关系：序号编码。<br>不具有大小关系：One-Hot编码+Embedding。<br>更多Hash/Binary。</p>
<ul>
<li><p>什么是组合特征？如何处理高维组合特征？</p>
</li>
<li><p>为什么L1正则化可以产生稀疏模型（L1是怎么让系数等于零的），以及为什么L2正则化可以防止过拟合?</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面筋</category>
      </categories>
      <tags>
        <tag>面筋</tag>
      </tags>
  </entry>
  <entry>
    <title>烤面筋 - 链接</title>
    <url>/work/interview/third-party/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第三方链接统计</p>
<a id="more"></a>
<p><a href="https://zhuanlan.zhihu.com/p/43661309" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43661309</a></p>
<p>CF,MF,Graph Embedding,LR,JVM,Quick Sort,Coroutine,Thread,Process,HashMap,RB-Tree,AVL-Tree</p>
<p><a href="https://blog.csdn.net/v_JULY_v/article/details/108292943" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/108292943</a></p>
<p>ML</p>
<p><a href="https://www.sohu.com/a/446356680_100205241" target="_blank" rel="noopener">https://www.sohu.com/a/446356680_100205241</a></p>
<p>Wide&amp;Deep,Join Training,Ensemble Training,DeepFM,Collaborative Knowledge Based Embedding,Knowledge Graph,Feature Engineer,</p>
<p><a href="https://blog.csdn.net/abcdefg90876/article/details/107373650" target="_blank" rel="noopener">https://blog.csdn.net/abcdefg90876/article/details/107373650</a></p>
<p>LSTM,SVM,GBDT,轮流捡石头,100盏灯问题,Overfitting,Dropout,Python,List,Mimimum Window Substring</p>
<p><a href="https://www.nowcoder.com/discuss/442650?type=2&amp;channel=-2&amp;source_id=discuss_center_discuss_hot" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/442650?type=2&amp;channel=-2&amp;source_id=discuss_center_discuss_hot</a></p>
<p>LR,L1 Norm,L2 Norm,Gradient Descendant,Momentum,Adam,XGB,Loss Function,FM,LR,Softmax,Sigmoid,TF SourceCode,Open Source,XGBoost,C++,AUC,XGB并行,模型优化算法,RMSprop,Adgrad,GMM,EM,Process,Thread,User Space,Kernel Space,</p>
<p><a href="https://www.nowcoder.com/discuss/596829?type=2" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/596829?type=2</a></p>
<p>XGB,GBDT,Recall,Rank,Recommender System Design,XGB,GBDT,LGBM,L1,L2,LR,SVM,XGB,Adam,SGD,Xavier,Loss,Recommender System Index,GBDT,LSTM,Train/Validation/Test Dataset,FM,FFM,XGB,GBDT,ETL,Feature Engineer,DIN,DICE,Dataset,Hyperparameter Search,Django,Flask,Nginx,Apache,CSRF,ORM reverse,Overfitting,LR,Tree,NN,Tuning,Data Lacking,XGB,GBDT,Softmax,LR,Classifier,Regression,DQN,Data Skew,Quantization,CNN,Recall,L2R,PS,Distributed Training,Tree Regression,XGB,GBDT,Softmax Overflow,Overfitting,HDFS,Fine Tune,Flink,Storm,Spark,Spark for Training,Kafka,Kafka Topic,Data Skew,W&amp;D,L2R,Lambda MART,Lambda Rank,NDCG,Position Bias,Cold Start,LSTM,LSTM Unit,Concave Optimization,SGD,OU,Replay Buffer,Sliding,LSTM,Layer,Unit,Data EDA,CNN,Tuning,FM,FFM,Postion Bias,Recommender System Index,Recommend Flow Orthogonal,DIN,Attention,XGB,Distributed XGB,Streaming,Flink,Spark,</p>
<p><a href="https://www.nowcoder.com/discuss/458758?channel=-1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/458758?channel=-1</a></p>
<p>Cache,HashMap,Guava Cache,</p>
<hr>
]]></content>
      <categories>
        <category>面筋</category>
      </categories>
      <tags>
        <tag>面筋</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 5-1 - 数据系统</title>
    <url>/ai/ml-system/big-data/1-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高效稳健的数据系统是保障各项业务运行的基石。</p>
<a id="more"></a>
<p>数据系统主要可以划分为：</p>
<ul>
<li>分布式文件系统，如HDFS。</li>
<li>数据收集，包括移动端埋点，服务端日志，第三方数据等</li>
<li>数据仓库，长期保存结构化数据，Hive，提供数据清洗，特征工程等功能。</li>
<li>数据湖，长期保存非结构化数据，如S3,Minio。</li>
<li>数据库，线上服务使用的数据源，按性能分关系型（MySQL，PostgreSQL），键值型（Redis内存），文档型（MongoDB，CouchBase内存），列存储（HBase）。</li>
<li>消息队列，模块解耦，如Kafka。</li>
<li>日志系统，ELK（ElasticSearch, LogStash, Kibana）。</li>
<li>计算引擎，按功能分实时（Flink，Spark Streaming），离线（Spark，Hadoop）。</li>
<li>ETL，日志抽取。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-1 - 后端硬件初探</title>
    <url>/ai/ml-system/hardware-backend/1-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>机器学习系统通常使用定制硬件后端执行计算密集型算子。训练模型中包含大量训练专用的反向梯度算子，相比之下推理模型结构更简单，算子集更小。因此定制硬件通常从推理模型入手。</p>
<a id="more"></a>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>如果采用异构计算系统的定义，硬件后端可以大致分为：</p>
<ul>
<li><strong>CPU</strong> </li>
</ul>
<p>对应最通用的计算设备，可以执行所有计算，灵活性最高，计算性能通常不够高。不过由于CPU的广泛通用性以及较低的成本，使用CPU做推理计算也很常见。</p>
<p>因此针对不同指令集的CPU也发展出了不同的优化方案，比如Intel加入了AVX512指令支持超宽SIMD指令，但直接加入编译选项对性能提升不明显，需要使用集合了Intel汇编工程师的智慧的MKL-DNN库，针对不同算子精心设计精细到cache-line的操作；Intel随后几代CPU又加入了VNNI指令（INT8支持，实际使用时也有限制）和BF16指令（详细见推理优化）。</p>
<ul>
<li><strong>GPGPU<a href="#refer-1"><sup>1</sup></a></strong></li>
</ul>
<p>对应计算密集型通用计算设备，可以执行有限的通用计算，取决于设备指令集。市场现状是，NVIDIA几乎垄断服务器级GPGPU供给，成本较高。CUDA软件栈闭源，优化通常只能基于NVIDIA提供的接口。不过也有一些奇技淫巧，通过接口劫持绕过CUDA软件的部分限制，需要一定的逆向工程的能力。</p>
<p>NVIDIA在模型量化（使用低位宽存储模型参数）上也很激进，INT8，INT4，FP16领先加入硬件。随之也出现过一阵超低精度paper热，使用2bit/1bit存储。如今，量化方案基本成熟，使用FP32训练，使用FP32直接推理，使用FP16/BF16推理精度略有，使用INT8则可能需要重新训练以恢复精度（详细见模型压缩）。</p>
<ul>
<li><strong>NPU</strong></li>
</ul>
<p>对应最专用的计算设备，通常支持的指令集最小，比如仅支持矩阵乘法，卷积，以及较常用的高频算子，执行效率最高。</p>
<p>几年前（现在是2020年）FPGA<a href="#refer-2"><sup>2</sup></a>凭借其相比ASIC<a href="#refer-3"><sup>3</sup></a>（专用定制芯片）的灵活可编程能力，一度出圈，成为深度学习硬件加速器的宠儿。不过，如今泡沫退去，一大批ASIC创业公司纷纷倒闭，FPGA自然也退回其最基础的应用场景（原型验证，低频可编程硬件）。</p>
<p>与此同时，NPU作为芯片的必备模块，已经与ARM整合进入手机CPU。一些大公司财大气粗，内部也在使用自研的特定场景芯片。</p>
<p>专用硬件突出“专用”二字，这意味着可以将应用场景无限缩窄。可以针对一类模型，甚至一种模型，甚至几种算子，针对性地使用大量专用优化。这样固然可能取得不错的性能，但是硬件开发本身相比软件来说慢得多。芯片的开发周期通常以年计，FPGA开发可能以月计，软件开发通常以周计。相较之下，必须要权衡开发时间、性能、成本以及通用性。</p>
<p>FPGA在芯片原型阶段的优势明显，如果大规模量产则成本与功耗都远高于ASIC。</p>
<p>另一方面，随着GPGPU的不断发展，先进工艺节点夹持，性能大幅提高，FPGA早期的低成本性能比的优势不复存在。在泡沫时期可能存在诸多在多项指标中平衡的特定场景硬件，但最终还是互相合并，收敛到几种硬件设计方案。</p>
<p>不过FPGA作为不错的早期原型平台还是有价值的，前端硬件的设计思路也和芯片设计相通，可以借鉴。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://zh.wikipedia.org/zh-hans/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">图形处理器通用计算</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" target="_blank" rel="noopener">Field-programmable gate array</a></li>
<li>[3] <span id="refer-3"></span> <a href="https://en.wikipedia.org/wiki/Application-specific_integrated_circuit" target="_blank" rel="noopener">Application-specific integrated circuit</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-10 - 后端硬件框架接入</title>
    <url>/ai/ml-system/hardware-backend/10-framework-integration/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开源背景下，框架在社区的加持下不断迭代，后端硬件通常不能cover所有应用场景，需要接入框架借用框架的能力。那什么样的实现最合适，又会有哪些问题？</p>
<a id="more"></a>
<p>按需求不同，可以有多种方法：</p>
<ul>
<li>不接入</li>
</ul>
<p>实际上还是借用了框架的模型定义。如果整个模型都能被支持，并且对性能有较高的要求，场景定制，那么可以不接入框架，比如TensorRT可以独立运行。</p>
<p>后端软件栈可能需要不小的开发工作支持长尾算子，达到全图覆盖，对于GPGPU这种适用面极广的后端硬件是可行的，TensorRT也标榜可以达到最高性能。</p>
<ul>
<li>算子内接入</li>
</ul>
<p>最直接的接入方法，利用后端软件接口直接在算子内实现等价逻辑，不用关心模型长什么样，而且不管支持了多少算子都能运行，提高覆盖率只是一个体力活。</p>
<p>这种方法针对计算密集型算子优化明显，尤其是当密集计算占比较高，其他计算和通信几乎不影响系统整体性能的时候。比如基于CNN的一系列模型，都可以用这种简单粗暴的方法先支持起来。</p>
<p>但这种方法的缺点也很明显，一旦计算较分散，每次执行算子都要做一次数据交换，对于图像类模型，带宽占用不低，会拖慢系统整体性能。</p>
<p>而如果为了最大化硬件利用率——计算时间占总运行时间的比例——加入指令队列，不做密集算子的interleaving，可能会引入较高的性能抖动。</p>
<p>除此之外，单算子性能最优并不必然意味着系统性能最优，系统最优通常需要在更高层面协调优化。</p>
<ul>
<li>图层面接入</li>
</ul>
<p>稍微复杂，借用了框架的算子调度能力。主要工作在如何从现有计算图中划分出适合的子图。如果子图过小，那么设备context切换（内存交换，通信）的开销就可能过大。</p>
<p>有时候会分出过多子图，但覆盖率很高，可能是子图间的特殊算子。</p>
<p>如果是训练算子，通常不会占用主计算通路，可以提前使用清理工具去除。</p>
<p>如果是Fusion等优化引入的算子，就可能需要“反编译”，把fuse起来的算子break down。</p>
<p>如果是控制结构切割了子图，需要从建模层面尽量消除控制结果，比如并行，展开，将控制结构放在生成代码而不是计算图里。</p>
<p>如果子图间不存在数据依赖，可以融合子图，减少通信开销。</p>
<p>上面提到的方法都需要根据实际情况取舍，因此，分图算法可能会引入更复杂的策略。比如在估计子图大小上，可以用最简单的个数阈值，也可以构建cost model。</p>
<p>Cost model可以根据shape和算子估算，也可以通过profling测量，后者相对于前者更自动化，并且可以支持运行时（动态）场景，而前者基本可以在编译时（静态）确定。</p>
<p>有时候分图算法过于粗暴，比如直接使用算子集，而后端硬件对结构有要求，则可能出错，需要有fallback机制，或者使用更灵活的模板匹配算法。</p>
<p>由于框架算子层接口可能随大版本更新变动，比如Tensorflow的Grappler（通常是因为protobuf版本问题），可能需要考虑兼容多版本，尽量解耦，复用代码。</p>
<ul>
<li>编译层接入</li>
</ul>
<p>为了用更通用，更自动化的方法优化能，减少手工优化的工作量，不少研究者提出借鉴编译器的思路，其中Tensorflow的XLA算是较早开始尝试的。</p>
<p>XLA<a href="#refer-1"><sup>1</sup></a>同样是在图层面接入的，也有一套分图算法，由于XLA使用的是编译，因此只要标记符合的算子即可。</p>
<p>XLA嵌在Tensorflow中，在运行时JIT执行，在分图后，符合条件的子图会开始编译流程，转换为HLO表示——更小的粗指令集合，如Softmax等算子可能被打散。</p>
<p>转换后的HLO执行一系列的设备无关优化，再交由后端设备Service处理，执行一系列设备相关优化，CPU可以通过LLVM Emitter发射为LLVM IR，交由LLVM编译为CPU后端指令。GPU等较通用设备可以复用LLVM Emitter结构，生成对应的指令。</p>
<p>编译后的指令会缓存在XLA的Compilation Cache中，根据Shape和Op计算Hash值存储索引。</p>
<p>在编译层接入，需要硬件具有一定的通用性，并且要在图层面实现设备相关的分图逻辑。虽然HLO缩小了算子集，但要求对编译后端有足够的了解，开发工作量不小。同样，图层面接口需要注意和版本解耦。</p>
<ul>
<li>其他</li>
</ul>
<p>接入后端的一个重要问题是线程冲突，需要通过全局线程池统一来解决，可以使用同一个线程池实现，或者是可控的线程数量。</p>
<p>编译优化之路总是吸引人的，通用自动化不重复也是人们不屑的追求。如果要全面支持各类框架，工作量也是不小的，通常会是社区为了推广框架，做不少示范性接入工作，测些数据，发些paper。大厂是否跟进，还是取决于最终收益。</p>
<p>不过现实是模型的根基并没有百花齐放，而是依靠一小撮人探索出的最高效的结构趋同了，因此大厂因靠不断累积手工优化经验，也已经能支持成熟可商业化的模型了。而各类编译方法面临的困境是无法在所有场景下大幅超越手工优化，主要是填补长尾空间。</p>
<p>历史积累的力量是强大的，不仅展示了持续规划迭代的惊人成果，同样意味着推到底层设施重来的阻力必然很大。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://www.tensorflow.org/xla" target="_blank" rel="noopener">XLA: Optimizing Compiler for Machine Learning</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-11 - 后端硬件系统</title>
    <url>/ai/ml-system/hardware-backend/11-system/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现代的服务系统已经变得庞大复杂，硬件后端需要与服务系统整合，才能在整个pipeline中发挥作用。相比于底层更关注局部性能，服务系统更关心端到端延迟，并发量和硬件利用率，性能稳定性，服务可用率等指标。</p>
<a id="more"></a>
<h1 id="Serving"><a href="#Serving" class="headerlink" title="Serving"></a>Serving</h1><p>后端硬件接入框架后，基本就可以依赖框架的Serving能力对外输出了。比如Tensorflow Serving、Torch Serve。NVIDIA也凭借硬件优势，提供了支持GPU虚拟化的Serving方案。</p>
<p>Serving框架相比于Training框架可以去除大部分逻辑，保留基本的计算调度和算子实现功能。框架通常基于Training框架的计算核心，封装模型加载，通信协议处理等逻辑。</p>
<p>框架基本的性能取决于计算核心，但更关注并发性能，使用HTTP/RPC等协议，RPC使用gRPC（Google）或Thrift（Facebook）等RPC框架。</p>
<p>通常可以进一步优化训练后的模型，使用比如子图融合，编译优化，模型压缩等方法，提高模型的推理性能，达到降低延迟，提高吞吐，降低成本等目的。</p>
<h1 id="容器化与隔离"><a href="#容器化与隔离" class="headerlink" title="容器化与隔离"></a>容器化与隔离</h1><p>随着容器化的流行，带来了无状态确保无副作用，开发和生产环境一致，环境可复现等诸多好处。构建一个容器化的Serving环境已经是基本操作。</p>
<p>容器和虚拟机不同，容器更轻量，也意味着隔离的不彻底。尤其是在多租户使用场景下，驱动文件可以直接mount，驱动层就需要考虑严格的内存权限设计。</p>
<p>而虚拟机层面需要一些设备虚拟化的工作，比如FPGA的虚拟化，通常这部分由云厂商提供。用户可以直接购买的云主机就是一台虚拟机，按资源量将一台物理机内存CPU拆分售卖，称为实例。如果需要物理机可以申请bare metal机器，但对于中小应用开发者，出于成本考虑，可能不会直接购买物理机。</p>
<p>虚拟机在一定程度上确保了CPU核和内存的隔离，但在Cache和内存带宽上的隔离比较困难。尤其是目前CPU通常使用HyperThread，相当于一个物理核，对应多个逻辑核（通常是两个）。申请小型实例——最极端情况是1核——就可能会遇到和其他实例共享物理核，影响性能。除此之外，多核CPU普遍使用NUMA结构，跨NUMA访问会对性能有较大影响。</p>
<p>云厂商提供的虚拟机的隔离性较高，但对于一个用户来说，不需要每个容器都通过实例隔离，而是需要和其他用户的容器隔离。一般通过云厂商提供的网络（VPC<a href="#refer-1"><sup>1</sup></a>）隔离，配置安全组限制访问权限。同一个VPC内的实例上可以放心部署用户的容器，容器的安全性由用户保证。在多租户场景，对隔离有较高要求的情况下，就会使用这种硬多租方案，申请实例，并与用户VPC连通。</p>
<p>Serving服务在部署时，通常需要注意容器的隔离，除了考虑多用户的安全性外，更多的是资源的隔离性，比如通过绑核来控制CPU的独占性，这在许多CPU推理优化方法中是很关键的。</p>
<h1 id="集群化与弹性"><a href="#集群化与弹性" class="headerlink" title="集群化与弹性"></a>集群化与弹性</h1><p>随着CPU性能触顶，从提升频率，到多核，再到分布式，对计算性能的需求推动了集群的大规模使用。<br>其中用于自动调度编排的系统Kubernetes<a href="#refer-2"><sup>2</sup></a>已经逐步称为集群开发的事实性标准，也称为云原生开发的基本“操作系统”。<br>类比于操作系统，应用对单台机器资源的管理调度（内存，CPU核，进程，线程等）等变成了对更宏观的云上资源（计算资源，数据库，网关等）的管理调度。</p>
<p>Serving服务同样可以融入这套系统。Serving服务注重的主要是以下几点：</p>
<ul>
<li>服务可用性</li>
</ul>
<p>这是排在第一位的，Serving服务是需要持续调用的，如果出现不可用，则可能造成巨大的业务损失。使用集群也有这方面的考虑，单一节点失效并不影响整体服务。</p>
<ul>
<li>性能稳定性</li>
</ul>
<p>在服务持续可用的情况下，服务调用的性能指标随请求量增减的波动不能过大，轻则链路延迟较高，业务体验下降，极端情况是超时，链路崩溃，业务不可用。</p>
<p>通常通过资源弹性满足性能稳定性，对于调用变化较缓慢的场景是适合的，资源随调用量，CPU水位（利用率），内存使用量等指标增减。</p>
<p>但对于瞬时调用量洪峰，则不可行，服务会出现短时不可用的情况，通常需要提前规划资源，灰度压测，保证在最高瞬时并发下服务的可用性。</p>
<ul>
<li>资源弹性</li>
</ul>
<p>对很多应用来说，实时调用存在明显的波峰波谷，比如在晚间最高，凌晨最低，调用规模可能差数倍，如果提前购置资源拉高成本，Serving服务应提供资源弹性，满足用户在成本和性能稳定性上的需求。</p>
<ul>
<li>资源超卖</li>
</ul>
<p>对于Serving服务提供者来说，如果使用自有集群，资源的持有成本是很高的，通常资源划分为半托管（代持用户资源），和全托管（自持资源）。</p>
<p>半托管下，用户完全为资源付费，通常是对性能指标极为敏感的，资源水位较低。而全托管下，由于不需要完全持有资源，用户成本可以降低，因此对性能指标没有那么敏感。</p>
<p>因此服务提供商会超卖，将多个服务调度到相同资源上，进而提高资源水位，节约成本。服务提供商通常会使用虚拟化技术，模型性能优化等方法，维持性能，不至于大幅影响体验。</p>
<ul>
<li>在离线混部</li>
</ul>
<p>Serving服务可以分为在线调用和离线调用。在线调用对延迟敏感，为保证响应延迟，通常资源水位较低。离线调用对单次调用延迟不敏感，要求总体吞吐，资源利用较充分。</p>
<p>因而两者的目标不同，通常会分池，划为在线和离线集群，互不影响。而出于成本考虑，在线调用有波峰波谷，完全可以在波谷时利用闲置的资源，一个是利用弹性，另一个就是混合部署。</p>
<p>混部对资源的隔离性的要求更高，但总体上可以降低运维成本，避免分池和资源调度的麻烦。</p>
<h1 id="接口统一"><a href="#接口统一" class="headerlink" title="接口统一"></a>接口统一</h1><p>Serving框架众多，最简单的可以用Flask包一个Python脚本就能服务。但对于Serving服务使用者来说，统一调用接口是一个必然趋势。可以避免切换模型训练框架对业务后端代码的影响。</p>
<p>比如Uber的Neuropod，AWS的SageMaker，Kubeflow的KfServing都在一定程度上制定了调用接口标准。</p>
<h1 id="后端硬件小结"><a href="#后端硬件小结" class="headerlink" title="后端硬件小结"></a>后端硬件小结</h1><p>机器学习模型服务只是整体数据分析链路中的一小部分，整体趋势是希望和具体框架解耦，并且自动化。因而机器学习系统通常和数据分析系统紧密联系，前端对接数据仓库，数据湖，后端对接业务后端，比如推荐系统，风控系统，BI（商业分析）系统等。</p>
<p>机器学习系统致力于更快捷，更自动化地构建部署机器学习模型。业务数据源源不断地产生，经过ETL汇入数据仓库，算法工程师进行特征工程，通过训练系统构建迭代部署机器学习模型，并固定为流水管线，通过AB Test系统上线验证效果并反馈迭代模型。</p>
<p>市场的粗放式扩张不再，转而对自己圈到的一亩三分地精耕细作。工程师们日复一日试图从庞大的数据中归纳出概率分布，去拟合稍纵即逝的注意力和兴趣的真实分布，优化漏斗变现的效率。</p>
<p>机器学习本身就是为了提高效率，降低成本，硬件后端的优化创新在整个成本效率优化链路中只占一个很小的点，市场枯荣会随本身ROI的评估而不断改变。</p>
<p>算法的更迭成本比起硬件小的多，当初认为不可解的循环迭代依赖也被替换成了符合GPU并行计算要求Transformer，硬件在定制应用上追着算法跑可能就像夸父逐日。</p>
<p>通用性和专用性的交替更迭，便随着经济周期波动下的新生与整合。</p>
<p>Xlinx被AMD收购，Nvidia吞并了ARM，巨头们纷纷试水GPU为破除Nvidia垄断，Intel在x86上三年又三年的缝缝补补，ARM和RISC-V已经NPU加入指令拓展。</p>
<p>FPGA只踏出了机器学习硬件后端的一小步，NPU已经融入了主流芯片，GPGPU的竞赛正如火如荼，CPU的指令集市场份额也在悄然演变。</p>
<p>谁能成为终局硬件？</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/Virtual_private_cloud" target="_blank" rel="noopener">Virtual private cloud</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://en.wikipedia.org/wiki/Kubernetes" target="_blank" rel="noopener">Kubernetes</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-2 - 后端硬件指令集</title>
    <url>/ai/ml-system/hardware-backend/2-instruction-set/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>定制计算硬件的一个重要任务是确定指令集<a href="#refer-1"><sup>1</sup></a>。对于深度学习模型，则要首先确定模型集，继而确定算子集，最后统计出指令集。</p>
<a id="more"></a>
<h1 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h1><p>总体上看，指令按计算密度分为计算密集型算子指令与长尾算子指令。</p>
<p>计算密集型算子指令通常就是指矩阵乘加计算，其他密集型算子（比如深度学习定义的卷积运算）可以通过变换转化为矩阵乘加。</p>
<p>因此矩阵乘加是定制硬件的核心，也是模型优化的核心。</p>
<p>换句话说，定制硬件（包括GPGPU）的主要设计工作在于如何在面积功耗约束下放下更多的矩阵乘加单元，同时提供匹配算力的存储访问带宽。</p>
<p>模型优化的主要内容就是在于如何合理排布硬件的矩阵计算指令和存储访问指令，使矩阵计算模型的实际利用率（有效计算时间占总运行时间）尽可能接近硬件的理论算力上限。</p>
<p>长尾算子指令则是针对出现在模型中但计算量不太大的算子设计的指令，但总体而言模型的复杂程度和改进速度都比硬件开发速度快，不可能浪费芯片面积支持所有的长尾算子，因此设计目标按优先级排序是：</p>
<ol>
<li>如果长尾算子不在模型首尾，而出现在两个密集算子之间，并且CPU计算开销（通常指耗时）相比交换给CPU计算（内存交换以及中断/轮询）的开销小，就应该尽量使用硬件计算。</li>
<li>归纳必须支持的算子，抽象出更通用的计算逻辑，尽量最小化占用的芯片面积。适配计算密集型指令算力和长尾指令算力，在多种目标场景中统计，长尾指令尽量不成为性能瓶颈。</li>
<li>评估大型模型（不能完全放在芯片内存中，需要和CPU主存交换）在目标承载系统中的算力适配程度，如CPU算力是否能支持内存拷贝开销，中断开销，硬件不支持的长尾算子的计算开销，系统其他服务开销。</li>
</ol>
<h1 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h1><p>指令是硬件向软件开放的“操作接口”，指令的粒度则决定了软件对硬件控制深度。</p>
<p>定制硬件的早期，尤其是针对某个特定模型的特定设计，软件和硬件都是及其专用的。硬件基本包揽了模型端到端的所有计算，甚至连模型结构也以一种“硬编码”的方式写在了驱动中。</p>
<p>硬件的整体架构只有两部分：一部分是寄存器，给软件配置来启动计算步骤，另一部分是一条巨大的流水线，归纳了整个模型最基本的计算结构，比如对于ResNet50，就是卷积-元素积-仿射变换-激活ReLU-池化。</p>
<p>软件<strong>运行时</strong>（Runtime）部分几乎就是很薄的一层，甚至可以大部分写在驱动中。<strong>驱动</strong>主要负责启动DMA读写数据以及配置查询寄存器。运行时只需要从某个地址读入输入数据，配置一个寄存器，接收到中断信号后读回数据写到另一个地址。</p>
<p>如果把配置寄存器也看作指令的话，那这就是<strong><em>最粗粒度</em></strong>的指令，软件没有控制的余地，指令可以写作<em>RESNET50</em> 🙂 。</p>
<p>逐渐地，需要支持更多相似模型，不同层数，不同长尾算子，则需要按层来配置卷积大小，长尾算子是否计算，有无pypass，内存数据如何存放等。硬件的流水线也配置了更多寄存器开关支持不同的计算路径。</p>
<p>这就是<strong><em>单层粒度</em></strong>的指令，软件可以通过一大组寄存器灵活配置每层的属性，也有了多模型interleaving（同时交叉）计算的空间。此时的指令可以写作<em>LOAD-CONV-ELTMUL-AFF-RELU-POOLING-STORE</em> 🙂 。类似粒度的硬件可以参考NVDLA<a href="#refer-2"><sup>2</sup></a>。</p>
<p>软件的功能逐渐增多，在运行时（Runtime）上增加<strong>编译器</strong>部分，将相近的算子变换为硬件支持的指令。硬件后端支持的模型更多了，但实际计算效率可能有所下降。这也是一个常识————通用性会牺牲专用性的性能，比如Windows和MacOS，CPU和GPU。但群体智慧的迭代可以逐步弥补通用性带来的损失，比如RISC与CISC，Android与iOS。</p>
<p>随着硬件的通用化，几乎不可避免地会向主流已验证设计靠拢，卷积计算将不再特例化，不断增加的变种支持会使硬件复杂度越来越来高。最终不得不回归本源————矩阵乘加，原本的超长流水线设计也会自然分化成两部分————密集计算单元与长尾计算单元指令。</p>
<p>密集计算单元由于去除了特例化设计，密度可以进一步提高；长尾计算单元将进一步整合，提高通用性。此时的指令进一步细化为LOAD，MATMUL，MULT，ADD，EXP，STORE等。指令操作的精细程度也进一步提高，类似SIMD操作。</p>
<p>多个计算单元和局部缓存构成一个计算引擎或者计算核，多个核可以由软件或者硬件直接调度（指令发射顺序），编译器的复杂度进一步上升，可以在更细粒度调整指令顺序，考虑缓存以及内存带宽匹配（Memory-Bound）。到了这个粒度的指令离GPGPU也不远了。</p>
<p>指令集基本划定了硬件可能的应用边界，不过实际硬件设计实现过程中还有其他要考虑的因素，取决于芯片后端与FPGA后端需求，略。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B" target="_blank" rel="noopener">指令集架构</a></li>
<li>[2] <span id="refer-2"></span> <a href="http://nvdla.org/" target="_blank" rel="noopener">NVIDIA Deep Learning Accelerator</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-3 - 后端硬件描述语言</title>
    <url>/ai/ml-system/hardware-backend/3-hardware-description-language/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>语言只是手段，不是目的。自然语言如此，软件编程语言如此，硬件描述语言也如此。</p>
<a id="more"></a>
<p>软件编程语言定义了一系列面向人类可读性的字符语法。人类使用软件编程语言编写描述机器如何处理信息的步骤的文本，简称为软件代码。使用编译软件使用指定指令集翻译成机器具体处理信息的指令，简称为程序。🤓</p>
<p>类似的，在硬件设计中，硬件的结构决定了功能，因此也需要借助一种文本描述硬件结构，得名硬件（结构）描述语言。</p>
<p>软件代码可以直接编译成程序运行，也可以直接和测试框架一起编译运行，测试功能正确性。</p>
<p>而硬件描述语言（HDL，Hardware Description Language）——其中对应硬件结构（可综合）的合法语法——只是对硬件的结构描述，需要使用仿真器（Emulator）构造硬件结构。</p>
<p>通常高效的仿真器会将硬件代码等价映射成软件代码（比如C++）编译后运行，提高仿真效率。</p>
<p>就可综合语法部分看，HDL乏像软件语言中的抽象模型，以用于代码复用。但是HDL中的寄存器、线以及模型足以描述任何复杂的硬件。可以利用软件工具管理生成代码，减少一部分coding的工作量。</p>
<p>比如使用脚本（Perl或者Python）管理模块，辅助连线，或者借用软件的OOP（Object Oriented Programming)模型，套壳做DSL（Domain Specific Language）（比如Chisel套在Scala里），借助套壳语言的语法和抽象简化硬件编码工作。</p>
<p>除了可综合语法，HDL中还引入了测试语法用来提供仿真激励。为了改进HDL的测试方面的短板，更多语法和抽象被引入进来，以至于可以被称为一门新的语言（比如System Verilog<a href="#refer-1"><sup>1</sup></a>)。</p>
<p>有趣的是，System Verilog可以被看作天然的并行语言，引入不少并发机制，比如channel，GoLang的并发机制里也有channel。</p>
<p>硬件开发的主要工作量并不在前端编码（主要包括编写Verilog并做功能仿真），占大头的是仿真测试和优化。在一些非自主开发IP的流程中，前端的工作基本就是把买来的IP（比如ARM）集成连线，写一些胶水逻辑。在一些自主IP定制的流程中，比如RISC-V，主要的功能还是在拓展指令集，然后接着大量测试和优化。</p>
<p>我曾经试图发明一门新的语言，使用现代语言的语法来改进Verilog。写好了词法Parser，拿到了AST，做了一些类型推断以及代码优化工作，可以生成Verilog。然而如果要用于生产，开发工作量是不小的。最终只是作为一个toy项目，帮我熟悉了一些编译器的知识。</p>
<p>现在回过头来看，如果考虑写一门HDL的话，需要考虑几点：  </p>
<ul>
<li>是否可以适配已有工业流程？通常是生成Verilog和其他EDA流程对接。</li>
<li>是否可以做到和Verilog可综合语法完全等价？需要形式化验证以及实际项目支持（比如Chisel傍上了RISC-V）。</li>
<li>是否支持其他blackbox（加密IP网表，VHDL，Verilog，SystemVerilog仿真模型）联合仿真？</li>
<li>是否能在保证仿真结果精度准确的情况下，提高仿真效率？只能粗粒度功能仿真就很鸡肋。</li>
<li>是否可以引入稳定的自动优化？怀疑是否又必要，后期优化的时候基本会扣每个寄存器，后端流程也有大量优化。</li>
<li>是否易学？过多的引入严格的抽象概念会大幅提高语言学习难度（用软件语言的角度类比，学go，可能3天上手写工程，学rust，学一个月可能还经常卡在工程编译上），HDL依赖惯性可能比软件语言要大的多。</li>
</ul>
<p>软件语言的迭代，引入了新的编程模型，新的内存管理机制，新的并行模型等等，实实在在地带来了极大的收益，大幅提高了并发性能，大幅减少了代码量，大幅降低了运行时排错的成本等等。</p>
<p>最终决定新语言是否会被大规模使用的核心还是：<strong>开发学习使用新语言引入的成本是否带来了足够的生产力收益</strong>。</p>
<p>HDL的核心功能还是描述硬件结构。</p>
<p>如果高层语言可以直接生成Verilog，要么是面向FPGA的HLS<a href="#refer-2"><sup>2</sup></a>（High Level Synthesis），面向软件工程师的硬件加速，根本不关心生成的代码，生成的代码也不可读。</p>
<p>要么是面向芯片的设计流程，语言本身最好能和硬件资源一一对应，所见即所得，否则就要生成可读的代码，让工程师检查。不过工程师既然都要人肉检查生成的代码了，再套一层壳就比较鸡肋了。</p>
<p>HDL已经深深嵌入到整个芯片设计流程中，前端和后端都能统一，EDA工具掌管着优化，VCS和Verdi已经是测试的标准工具。相比软件语言，HDL是一个非常细分且小众的DSL。</p>
<p>也许，之后会有新的HDL成为事实的工业界标准，但应该会是一个漫长的过程。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/SystemVerilog" target="_blank" rel="noopener">System Verilog</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://en.wikipedia.org/wiki/High-level_synthesis" target="_blank" rel="noopener">High-level synthesis</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-4 - 后端硬件验证</title>
    <url>/ai/ml-system/hardware-backend/4-verification/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>仿真不是真，只不过是现实世界的一个有限切面。但仿真又是在进入现实世界前的必经试炼。</p>
<a id="more"></a>
<p>仿真（Emulation）用来从底层机制层面模拟硬件运行性能，测试功能正确性，评估性能是否达到设计标准。</p>
<h1 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h1><p>项目启动阶段重心放在硬件功能开发上，而验证流程可能处于刀耕火种阶段：</p>
<ul>
<li>C++写Test Case，dump输入数据文件和输出结果文件，要求转化成Verilog-friendly 16进制字符串</li>
<li>手写Verilog读取文件，围绕仿真激励逻辑，dump波形文件和输出结果文件</li>
<li>diff比对Test Case和Verilog的输出结果文件，匹配不上需要看波形定位问题</li>
</ul>
<p>实际生产中需要完善的仿真测试来保证达到设计目标，尤其是芯片，毕竟比较贵。如果流片回来变砖就很尴尬了，赶在流片前，尽力而为。</p>
<p>和软件测试类似，硬件验证也分为不同层级。根据粒度可以将仿真分为：</p>
<ul>
<li><strong>单元仿真</strong></li>
</ul>
<p>测试基础功能模块是否达到设计目标，通常设计一些测试用例（Testbench）来验证，基本作用与软件单元测试（Unit Test）类似。</p>
<p>软件测试的基础单元是函数（Function），硬件测试的基础单元是模块（Module），需要选择合适的测试粒度大小。</p>
<p>TDD<a href="#refer-1"><sup>1</sup></a>（Test Driven Development）适合拆解开发工作量，也可以用于硬件开发。</p>
<p>由于HDL及其周边工具的迭代速度缓慢，语言编程接口与仿真调试工具的易用性与软件相比，并没有显著性提升。因此在以开发速度远超ASIC闻名的FPGA开发流程中，单元仿真可以是不存在的。</p>
<p>至少在一个项目进度很紧的早期团队中是不存在的。</p>
<ul>
<li><strong>系统仿真</strong></li>
</ul>
<p>这里基本实现了较独立的完整功能。为了提高仿真速度，一般去除比较独立的寄存器逻辑，仿真非常耗时的存储器（如DDR仿真模型）逻辑等。</p>
<p>即便去除了一些耗时的逻辑，硬件仿真的耗时相比软件高出不少，并且还没有测试Cache机制，每运行一次可能需要数个小时，导出的波形文件也非常大。</p>
<p>除了一些用来跑通控制流和数据流的Case之外，一般也会采用遍历（case较少）或者随机测试，最终看代码覆盖率。<br>如果要做比较完善的测试，靠刀耕火种的流程肯定是不够的，自动化（Automation）是必须的。</p>
<ul>
<li><strong>后仿真</strong></li>
</ul>
<p>后仿真，是指可以在每个后端流程（综合，布局布线）后抽取HDL仿真。用于检查流程是否出错，以及时序验证。前端也可以手动加入一个delay（不会被综合，但可以指导仿真），模拟信号固定延迟，波形上好看一些。</p>
<p>FPGA几乎从不后仿，非常费时，不如可以直接上板，通常一些只有上板才出现的问题也仿不出来。</p>
<ul>
<li><strong>上板调试</strong></li>
</ul>
<p>通常使用FPGA开发板，因此称为上板调试。在芯片验证流程中，FPGA被用来做原型验证，一般降频运行，测试功能时序正确性。</p>
<p>容易遇到的问题是，测试模型需要用软件重写，导致引入额外bug。</p>
<p>如果真的遇到了和预期不符的地方，调试起来就比较费力。需要使用FPGA IDE的信号抓取功能添加信号线作为debug逻辑，再重新跑后端流程。</p>
<p>当FPGA项目比较大时，一次可以抓取的信号数量有限，需要同时编很多版本。在FPGA资源已经比较吃紧的情况下，拥塞程度较高，添加过多信号线，会让时序优化更有压力。</p>
<p>实际测试下来发现，很多bug都是因为Test Case不够全。因此要尽可能在之前的仿真中测出bug啊！</p>
<p>如果遇到了抓信号也不好复现的bug：</p>
<ul>
<li>有可能是跨时钟问题，这个在仿真中不太好复现。</li>
<li>有极小可能（真的碰到过）是定制板卡的PCB版设计有问题。</li>
<li>几乎没有可能是因为宇宙射线引起的单粒子反转效应。😃</li>
</ul>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>测试框架可以使用System Verilog的UVM<a href="#refer-2"><sup>2</sup></a>（常用的芯片工业的验证框架）或者基于Python的Cocotb<a href="#refer-3"><sup>3</sup></a>。</p>
<p>深度学习的FPGA后端的核心功能是offload计算密集型算子，并且与标准框架（Tensorflow，PyTorch）实现比对数据，对验证的覆盖性要求不高。可以使用基于Python的Cocotb，使用Python编写测试逻辑的好处是有大量可用包，写数据处理逻辑比较方便。</p>
<p><img src="/images/cocotb.svg" alt="基于COCOTB的协同仿真框架"></p>
<p>Cocotb只提供了核心组件和System Verilog的VPI<a href="#refer-4"><sup>4</sup></a>连接，需要编写硬件激励的Driver，把Python数据转换成硬件信号，比如AXI/AXI-lite Driver；编写信号采样Probe，把硬件信号转换成Python数据。</p>
<p>向上封装类DMA的驱动接口，包括DMA数据读写以及寄存器读写。这样在这个层面可以做到和驱动接口统一，便于在上板测试时保持上层激励逻辑不变。</p>
<p>再向上封装硬件相关的运行时（Runtime）模型，直接配置硬件指令，运行时模型负责模拟内存分配，数据和指令读写等功能。使用者只需要指令遍历指令的集合验证即可。</p>
<p>由于Verilog仿真速度很慢，在指令遍历选项过多的情况下会非常耗时，一般选择直接上板遍历，并记录对应失败配置，有针对性地对失败的case仿真调试，查看波形。</p>
<p>收获的一个经验是：</p>
<ul>
<li>测试越早写，收获越大，可以有效减少系统调试时一些花了很久定位的“显而易见”的bug。但目前还不知道怎么能提高写测试的积极性，降低写测试的overhead。</li>
<li>绝大多数代码只会被用一次。</li>
</ul>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener">Test-driven development</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://en.wikipedia.org/wiki/Universal_Verification_Methodology" target="_blank" rel="noopener">Universal Verification Methodology</a></li>
<li>[3] <span id="refer-3"></span> <a href="https://github.com/cocotb/cocotb" target="_blank" rel="noopener">cocotb/cocotb</a></li>
<li>[4] <span id="refer-4"></span> <a href="https://en.wikipedia.org/wiki/Verilog_Procedural_Interface" target="_blank" rel="noopener">Verilog Procedural Interface</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-5 - 后端硬件后端流程优化</title>
    <url>/ai/ml-system/hardware-backend/5-fpga-backend/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里说的性能优化不是计算性能优化，比如脉动阵列的优化，而是如何使硬件设计在FPGA后端流程中时序尽量不违例。</p>
<a id="more"></a>
<p>FPGA的好处挺多的，可以芯片的价格也是美丽的。资源越多，价格越贵，而且还有不同资源配比，满足不同需要。<br>一般来说，FPGA中的关键资源包括：</p>
<ul>
<li>DSP（乘加单元），代表了绝对算力，也是有一段短暂的时间FPGA可以和GPU叫板的主要支持因素。</li>
<li>BRAM（片上存储），代表了Cache大小，大到可以把模型整个都放上来，不过实际上只需要放下提前prefetch的数据即可，通过pipeline屏蔽DDR读取latency。</li>
<li>FF（锁存器），代表了寄存器总量，一般不太会不够用吧。</li>
<li>布线资源，影响通用逻辑复杂程度。</li>
<li>LUT（查找表），影响通用逻辑复杂程度。</li>
</ul>
<p>那个时候，大家的工艺节点还差不多，Xilinx猛怼DSP，单个封装内3D堆几个die，加上FPGA工程师使用的倍频技巧，实际计算效率还能和GPU比一比。</p>
<p>后来，NVIDIA财大气粗，逐步垄断市场，算力每代大跃进。Xilinx起初还想以ACAP<a href="#refer-1"><sup>1</sup></a>——同时集成ARM、FPGA、CGRA的巨兽——反超。</p>
<p>但无奈ACAP还是难产，大部分时间停留在励志吃下5G、自动驾驶、人工智能等多个领域的PPT中。即使真的大规模量产，成本也是可以想象的没有竞争力。最终，做FPGA加速器的，还是老老实实回去做芯片了。</p>
<p>FPGA后端指的是Synthesize和Implementation，Implementation包括Remapping，Placing、Routing等。</p>
<p>相比芯片要傻瓜的多。通过XDC约束布局布线，更换策略，画pblock等方法降低违例TNS（Total Negative Slack）。</p>
<p>通过阅读STA报告，我们基本能定位有问题（比如fan out过高，WNS明显过小，拥塞等级过高）的地方，反过来修改设计，比如插入寄存器，对跨时钟的逻辑set_false_path，或者手动复制寄存器等等。</p>
<p>DSP一般被用来搭建计算密集型算子，元素积或者自然指数通常用LUT搭乘法器，根据频率调整合适的pipeline级数，前后插入寄存器提高时序。</p>
<p>控制跨die信号总量，跨die频率尽可能的低，前后加寄存器。</p>
<p>多阅读官方文档，熟悉底层器件特性，明白自己写的代码映射到什么样的硬件结构上，参考示例工程。</p>
<p>Garbage in, grabage out。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://www.xilinx.com/products/silicon-devices/acap/versal.html" target="_blank" rel="noopener">Versal</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-6 - 后端硬件软件栈</title>
    <url>/ai/ml-system/hardware-backend/6-software-stack-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没有软件支持的硬件就是一块砖，围绕硬件编写通用且易用的软件栈所需的资源以及重要性不亚于硬件开发。</p>
<a id="more"></a>
<p>在硬件工程师主导的团队中，可能会忽视软件的作用以及开发工作量。</p>
<p>因为从硬件的角度来看，软硬件接口的抽象非常明确：</p>
<ul>
<li>寄存器表</li>
<li>数据</li>
<li>指令</li>
</ul>
<p>后端硬件通常暴露一组控制寄存器，上层软件通过驱动读写寄存器，完成初始化，复位，状态监测等操作。</p>
<p>后端硬件和主控CPU通过主存交换数据和指令，硬件指令解析器读取指令并发出相应的信号影响控制流和数据流。</p>
<p>然而软件工程需要在软硬件接口之上做多层封装，提供不同层次的接口抽象，满足不同需求的用户。</p>
<h1 id="驱动（Driver）"><a href="#驱动（Driver）" class="headerlink" title="驱动（Driver）"></a>驱动（Driver）</h1><p>软件层最底层的封装，与操作系统耦合，提供最基本的硬件控制接口，基本和软硬件接口一致，比如读写寄存器表，读写存储器数据等。</p>
<p>但通常处于安全性考虑，驱动不会直接提供上面的功能，而是进一步封装，提供执行特定功能的接口。一个接口中，可能执行多个寄存器和存储器读写操作。</p>
<p>除此之外，驱动运行于操作系统层，天然具备跨进程的能力，因此在驱动也会负责跨进程的硬件状态管理，比如内存管理，指令调度等。</p>
<h1 id="运行时（Runtime）"><a href="#运行时（Runtime）" class="headerlink" title="运行时（Runtime）"></a>运行时（Runtime）</h1><p>用户使用驱动可以最大程度的控制硬件逻辑，但相应的所需要编写的代码量相当可观，因此，驱动层之上还会封装runtime。</p>
<p>runtime通常提供更高层次的抽象接口，进一步屏蔽硬件初始化，上下文（context）管理，设备管理，以及指令/数据的显示加载读取等操作。</p>
<p>总体上来看，runtime的性能相较驱动没有太多损失，但易用性大为提升，错误反馈和排查功能也更为友好。</p>
<p>因此，如果不是对硬件控制有特别高的需求，会使用runtime接口编程。</p>
<h1 id="计算库（Libraries）"><a href="#计算库（Libraries）" class="headerlink" title="计算库（Libraries）"></a>计算库（Libraries）</h1><p>编写硬件指令，由其是高效的硬件指令需要对硬件结构有深刻的理解，但是手工编写硬件指令对更高层的用户（比如算法工程师）来说是不够友好并且困难的。</p>
<p>因此后端硬件官方或第三方通常会提供特定领域计算库，提供常见计算pattern的接口，内置凝结了工程师智慧的手工优化代码，比如CuDNN，MKL-DNN等面向深度学习的计算库。</p>
<p>一般来说，硬件厂商提供的计算库性能高于第三方开发的计算库，毕竟对于硬件结构的理解更深入。但是第三方在应用上的创新速度远快于硬件厂商的响应速度，各家厂商对于应用的参与和主导程度也会影响计算库的迭代速度和易用性，比如NVIDIA和Intel。</p>
<h1 id="计算框架（Framework）"><a href="#计算框架（Framework）" class="headerlink" title="计算框架（Framework）"></a>计算框架（Framework）</h1><p>计算库提供了特定计算pattern的优化指令，尤其是对计算密集型算子，提高了硬件利用率。但对于一个特定应用来说，还需要足够灵活和高效的计算框架的支持。</p>
<p>对于深度学习应用，计算框架（比如Tensorflow和PyTorch等训练框架）提供了算子级别的抽象，使用Python定义DSL，让用户灵活构建计算图，并提供了反向梯度计算，方便训练。</p>
<p>服务框架用来将训练后的模型部署为在线服务，供业务应用调用，通常使用训练框架的计算核心，但是更注重面向网络接口的高可用，高并发等特性。</p>
<p>后端硬件通常只能支持主流框架全部算子的子集，需要接入框架提高可用性，否则，整个计算图都能在专用硬件上运行的概率不会太高。接入过程主要考虑调度，算子融合，以及常规的编译优化手段。</p>
<h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><p>业务应用通常使用微服务架构，各个模块间相互独立。业务应用负责处理数据处理，格式转换，模型调用等任务。</p>
<p>业务应用从前端被动获取数据（比如用户的行为数据），或者从数据库/数据仓库中取数据，通过RPC<a href="#refer-1"><sup>1</sup></a>或HTTP调用机器学习模型在线服务，根据服务返回结果（比如物品推荐的打分）执行数据处理操作（比如筛选排列返回给前端的物品呈现顺序），优化某项业务指标（比如点击率或观看时长）。</p>
<p>机器学习服务有SaaS<a href="#refer-2"><sup>2</sup></a>化的趋势，对小微用户来说，招聘全职的算法工程师和平台工程师的风险偏高，且限于技术深度相对不可控。SaaS服务提供了更高层的使用接口，甚至是无代码操作方式，标准化托管用户的数据收集、处理、分析流程，根据用户的不同需要（比如推荐、风险控制、用户增长等）提供不同类型的服务。</p>
<h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>基于数据分析的业务决策已经被实践证明在优化某些特定业务指标时效果明显，但数据分析逐步普及的趋势下，似乎陷入了电影院困境，大家被迫要用数据分析来决策。</p>
<p>数字化确实能带来效率提升，紧随其后的大数据计算利用机器学习在试图在微观层面上找到一些可以带来收益的价值，也就是所谓的挖掘数据中的金子。</p>
<p>智能化是在数据、算力双双获得爆发性增长后的趋势，但目前的智能化仍然只能看做大数据分析的进一步发展形态，依赖算力和数据规模暴力拟合。</p>
<p>因此而消耗的能源和人类时间，给环境造成的影响是否真正创造了等量的价值呢？</p>
<p>正如模型训练步长过小容易陷入局部最优解，依赖于一个个AB Test做出的短期决策是否对长期价值有贡献呢？</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">Remote procedure call</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://en.wikipedia.org/wiki/Software_as_a_service" target="_blank" rel="noopener">Software as a service</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-7 - 后端硬件驱动</title>
    <url>/ai/ml-system/hardware-backend/7-driver/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>驱动是对硬件接口的抽象和封装，设计时需要充分考虑分层和解耦。</p>
<a id="more"></a>
<p>Linux系统将设备<a href="#refer-1"><sup>1</sup></a>抽象为文件，比如字符设备、块设备和网络接口，保持和文件一致的读写接口。</p>
<p>拓展卡类型的FPGA加速卡使用GPIO和PCIe相连，内置PCIe Controller和DMA提供统一寻址。DMA提供多组AXI总线（通常与DDR空间对应，DDR空间不足可高位截断）以及一组AXI-lite总线（通常和用户寄存器空间对应）。</p>
<p>FPGA硬件设备驱动的核心模块是DMA驱动，配合scatter-gather DMA，负责数据在主存和设备存储间的交换。</p>
<p>用户软件通过设备文件的读写接口发起大规模DMA读写，通过ioctl等系统调用定制接口，比如寄存器读写等。</p>
<p>FPGA芯片厂商通常提供DMA驱动，对FPGA开发者屏蔽了PCIe/DMA寄存器的操作细节。因此在驱动和硬件两侧看来，驱动设备文件的数据读写接口和AXI总线接口完全对应。</p>
<p>硬件加速器会基于FPGA厂商提供的驱动对应硬件功能做二次开发，一是向runtime屏蔽硬件操作的复杂性，复用操作逻辑，二是保护硬件，防止用户软件对硬件执行非法操作。</p>
<p>对于深度学习硬件后端，驱动的功能主要分为：内存管理，引擎管理，指令调度等。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>驱动最简单的管理策略就是直接放开所有物理内存空间，用户可通过读写接口访问任意内存地址。</p>
<p>但这是个危险的操作，多个用户进程可能直接地址冲突，相互干扰，导致硬件逻辑错误。否则就要修改代码，对每个进程配置一个基地址。对于同构逻辑可能还行，如果是通用逻辑则无法保证均匀切割的地址空间能满足所有进程的需要。</p>
<p>因此，驱动应提供内存管理的功能，在用户进程发起写请求前，显式申请内存空间，并在进程退出后清理所有残留内存空间。</p>
<p>更为安全的做法是使用虚拟内存，将硬件的物理内存地址空间（有可能不连续）映射到连续的内存空间，相应的返回给用户的是虚拟内存地址。用户不能直接操作物理内存地址，同时对用户读写请求做内存地址所有权检查，禁止非法访问。</p>
<p>不过通常安全性和性能是相互限制的，在高频读写场景下，可能会影响系统整体吞吐。对于延迟敏感型应用可能有较大影响，应根据实际场景取舍。可以加入安全模式或低延迟模式的选项，满足不同场景的需要。</p>
<p>内存管理的另一个问题是，内存碎片。</p>
<p>如果采用直白的顺序分配方式，不仅在碎片数量上升的情况下，内存分配时间逐步上升，而且可能会在多轮地址全部分配后出现大量碎片，难以重新分配。</p>
<p>因此一个可以直接想到的方法是，预先将内存切割为大小均等的块，在内存分配时给出适合大小的块，使用bitmap记录内存使用情况。</p>
<p>指令内存和数据内存的大小通常相差很多，可以根据业务场景预设多种尺寸的内存块。这样会浪费一些内存空间，极端情况是场景所需内存恰好超出预设尺寸一些，必须要分配更大尺寸的空间，不过这样设计的好处是，内存管理逻辑相对简单。</p>
<p>如果要进一步优化内存使用率，可以使用均等切块，不连续内存访问的方式，由驱动控制数据的拆分，可能会将单次DMA读写拆分为多次。如此引入的额外性能开销，驱动复杂性和调试难度等，需要结合业务通用程度和团队产能平衡。</p>
<h1 id="引擎管理"><a href="#引擎管理" class="headerlink" title="引擎管理"></a>引擎管理</h1><p>密集型算子的计算核心对应硬件的计算引擎（计算核），同构结构下多个计算引擎的结构与性能完全一致，可能分别置于多个die上（有时候，为了压低单位算力成本需要高超的FPGA后端技巧）。异构结构可能分为大小核结构和完全异构结构。</p>
<p>使用大小核是为了充分满足设计上限（受限于给定可用资源或面积）。设计标准核的性能算力最佳，但占用资源较多。在设计上限内，不能完整容纳另一个标准核，但可以容纳阉割核（砍计算位宽，降频等）。但大小核功能基本一致，但是性能有差异。</p>
<p>完全异构核是指设计功能不同的计算核，比如拆分计算密集型和长尾通用型计算核，或者针对特定场景（比如推荐）设计特定计算核（比如Embedding）。</p>
<p>驱动设计时需要考虑上述各种情况，可以根据实际应用场景取舍。</p>
<p>一个硬件版本会对应一组硬件结构，可以通过配置文件的形式对应硬件寄存器版本信息。驱动在初始化设备时，创建对应的数据结构，不同类型的核对应不同的引擎类型。对外提供引擎分配，释放，启动，重置接口等。</p>
<h1 id="指令调度"><a href="#指令调度" class="headerlink" title="指令调度"></a>指令调度</h1><p>对于完全同构引擎，驱动在分配时可以使用独占或共享策略。</p>
<p>独占策略声明引擎的排他性，通常是处于应用低延迟需要。由其是在没有引入指令交叉发射的机制下，共享同一个引擎的应用可能会被block较长时间，造成较高的延迟抖动。</p>
<p>共享策略是为了最大化吞吐，多个计算指令填充队列，屏蔽数据交换的overhead。</p>
<p>异构结构引擎的分配策略类似，需要考虑是否需要区分大小核。</p>
<p>实际上提前由用户进程分配物理引擎并不一定是最优方案，尤其是在用户进程没有全局信息的情况下。驱动可以负责指令的动态调度，使用虚拟引擎屏蔽物理引擎细节。</p>
<p>在分配引擎时，并不直接分配物理引擎，而是分配一个虚拟的引擎（持有类型信息），在实际启动引擎时，使用round-robin策略、按优先级或按负载调度指令。</p>
<p>在某些场景下，硬件物理引擎只有一份，但最大可以处理N条指令（队列深度）。驱动可以通过维护指令队列的方式和硬件结构对应，实时查看硬件的队列深度，但这样会引入轮询开销。</p>
<p>另一种做法是分配N个虚拟引擎对应一个物理引擎，并使用独占的方式，每个引擎阻塞执行，如此一来驱动就不必关心指令队列的实时状态了。总体上看，由软件调度的性能开销和抽象复杂度都较高。</p>
<p>另一种思路是将指令调度下沉至硬件，驱动单纯负责内存分配和数据交换，以及简单的引擎管理功能。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>性能优化是必然要提到的，大体说来就是锁和合并。</p>
<p>多线程应用/多进程应用在驱动中的行为基本一致（除了内存共享），那么最应该注意的就是加锁问题了。</p>
<p>一个是mutex和spinlock，mutex会调用sleep，并切换context，spinlock则会反复尝试unlock直到成功。</p>
<p>另一个是精细加锁，不要在整个函数出入口加一把大锁，非常容易引起性能问题。</p>
<p>中断处理是需要消耗资源的，硬件过多的中断信号可能会丢失，或者造成CPU0占用过高，硬件可以提供中断合并的机制，降低实际中断次数。DMA的启动也有开销，因此需要考虑如何减少DMA读写次数，或者overlap启动开销。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/Device_driver" target="_blank" rel="noopener">Intermediate representation</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-8 - 后端硬件运行时</title>
    <url>/ai/ml-system/hardware-backend/8-runtime/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>运行时（Runtime）抽象出计算模型，提供更通用的接口，进一步屏蔽硬件细节。</p>
<a id="more"></a>
<p>在深度学习硬件加速系统中，如果仅依赖驱动接口，业务层/编译层代码中仍然要编入硬件相关代码，需要管理设备，记录内存，整理数据等，耦合较重，迁移困难。</p>
<p>在驱动之上封装一层runtime有利于进一步提供代码复用程度，将硬件实现和上层应用完全解耦。</p>
<p>在后端硬件系统设计早期，很可能因为项目压力而倾向于把所有功能写在一起：</p>
<ol>
<li>程序读入模型并统一转换为内部定义的模型标记格式。</li>
<li>接着程序根据标记构建计算图，优化使得计算图的pattern符合硬件需求。</li>
<li>随后程序根据硬件结构执行算子融合，并生成对应的硬件指令。</li>
</ol>
<p>此时，应用层、编译层、运行时完全耦合，专为应用定制设计，模型结构也可能硬编码在代码里。</p>
<p>这样的设计会带来不少问题：</p>
<ol>
<li>整个程序更重，基本上要保证能执行全部算子，否则需要将框架反向接入，使用框架的算子覆盖长尾逻辑。 </li>
<li>代码高度耦合，换个模型，换个应用就要重写大量代码，为了同时支持多个应用，需要把所有代码全部展开，不利于版本管理和代码复用。</li>
<li>调试极不方便，模型，编译，运行时每一层都有可能有出错的可能，但因为缺少明确的接口，基本上只能端到端调试。</li>
</ol>
<p>因此，需要分层设计软件，解耦逻辑，复用代码。</p>
<p>从运行时的角度看，用户可能以多种形式使用：</p>
<ol>
<li>直接使用，对硬件结构熟悉，通过运行时提供的接口简化操作。</li>
<li>接入框架，需要在算子内生成运行时所需的数据。</li>
<li>接入编译，接受编译层的通用中间表达（IR<a href="#refer-1"><sup>1</sup></a>），根据硬件结构转换成指令，屏蔽硬件细节。</li>
<li>调试使用，提供Python接口，方便运行调试。</li>
</ol>
<p>通过合理的抽象，就可以满足使用需求，并保留足够的扩展性。</p>
<h1 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h1><ul>
<li><strong>内存抽象</strong></li>
</ul>
<p>对驱动来说，其并不关心DMA下发的数据具体是什么类型，也不会关心内存和哪个具体模型对应。</p>
<p>对用户来说，其并不关心内存分配地址，也不关心硬件运行细节，最好作为函数接口调用。</p>
<p>因此，可以将内存抽象为三种类型：</p>
<ol>
<li>Blob。动态数据块，仅记录形状信息，需要在运行时传输，每次调用计算均会被改变。</li>
<li>Data。静态模型参数，编译时确定，声明周期和模型相等。</li>
<li>Instructions。计算指令，其中内存地址需要动态映射。</li>
</ol>
<ul>
<li><strong>设备</strong></li>
</ul>
<p>设备（Device）抽象负责硬件设备初始化，设备分配，拥有设备相关执行逻辑。</p>
<p>设备抽象和硬件实现相关，通常和计算核对应，提供计算核申请与维护，内存申请与维护，指令解释（内存地址映射），数据重排，量化，精度转换等功能。</p>
<ul>
<li><strong>多模型</strong></li>
</ul>
<p>使用Executor机制，根据IR标识（比如哈希值或者校验和）区分不同模型。</p>
<p>对一个新IR，创建对应Executor以及State，并在Executor首次调用时调用Device的初始化接口，IR信息（比如计算核handler以及内存地址映射表等）保存在State中。之后调用Device的运行接口，考虑到多线程支持，State信息可能会被同时访问，仅设置为只读。</p>
<p>对单个模型的多线程调用，分配线程级数据结构保存当前调用的Blob分配信息，调用结束后销毁，避免加锁。</p>
<p>多后续标识相同的IR，通过cache表查到对应的Executor调用。</p>
<ul>
<li><strong>接口</strong></li>
</ul>
<p>也就是IR定义，主要包括：</p>
<ul>
<li>IR标示符</li>
<li>设备类型</li>
<li>动态数据表</li>
<li>静态数据表</li>
<li>计算指令表</li>
</ul>
<p>其中还可以详细定义是否支持Dynamic Shape，是否需要完全内存映射等，量化精度，数据精度，数据对齐等。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>运行时作为调用的关键路径之一，性能优化也相当重要，常用的优化手段包括：</p>
<ul>
<li>资源池。</li>
</ul>
<p>考虑到多线程调用时，每次调用的动态内存申请开销。在专用场景下，每次调用动态内存尺寸不变，可以使用资源池提前分配，并在每次调用时申请。资源池一般需要加锁，资源池大小可根据IR信息配置，也可开放接口供用户配置。</p>
<ul>
<li>CPU Affinity</li>
</ul>
<p>考虑到线程中断开销通常集中于CPU0，多线程使用时希望规划计算使用，也就是设置线程级CPU亲核性。开放亲核性配置供用户配置。</p>
<ul>
<li>硬件Warm-UP</li>
</ul>
<p>硬件pipeline填充也需要时间，首次启动时需要从DDR加载数据，针对特定应用，数据加载完成后不会反复swap，可以提供warm up接口，使用atomic变量，在首次运行时填充特定寄存器。</p>
<ul>
<li>DMA合并</li>
</ul>
<p>DMA的读写开销并不低，如果是IO数据块（处于计算首尾的需要和主存swap的动态数据块）较多，则可能拉低系统整体性能。驱动对内存连续性无法判断，可以在runtime内存申请时提前合并IO数据块，将DMA读写次数合并为1次，提高系统整体性能。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>主要是C++编程的一些吐槽。</p>
<ul>
<li>多线程安全</li>
</ul>
<p>合理规划数据，优先选择不加锁。如果一定要加，根据场景加合适的锁，合理使用线程级数据/原子变量。</p>
<ul>
<li>指针安全</li>
</ul>
<p>野指针很危险。有时候系统通过原始指针对外需要暴露C API，但在进入C++部分后，需要合理使用unique_ptr，shared_ptr，std::move等限定和转移指针使用权。不然double free，空指针报错就很有可能出现，许多小项目在运行完之后抱一个指针错误，反正也查不出来是哪，就凑合着用了。</p>
<ul>
<li>内存访问</li>
</ul>
<p>数组下标越界引起的segment fault，在stack trace中并不能反应出来，很可能是程序欢快地运行很久之后突如其来，记得检查。查错时也可以上valgrind之类的内存统计工具，不过程序过大时，各种loss就可能让人眼花缭乱了。</p>
<ul>
<li>内存泄露</li>
</ul>
<p>内存泄露的排查也比较艰难，使用内存统计工具，排查各种指针使用情况之后，大概能解决绝大多数bug。但有些因为内存分配策略导致的内存使用量持续升高可能就和模型相关了（比如Tensorflow），需要具体分析。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/Intermediate_representation" target="_blank" rel="noopener">Intermediate representation</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 1-9 - 后端硬件编译器</title>
    <url>/ai/ml-system/hardware-backend/9-compiler/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>编译，广义上是将一种表达映射成另一种表达，维持功能不变。深度学习后端硬件的编译，是将DSL描述的计算图映射成后端硬件指令。</p>
<a id="more"></a>
<p>传统编译器直接解析文本，通过词法与语法分析，构建AST<a href="#refer-1"><sup>1</sup></a>。之后在AST上执行一系列的优化，称为优化pipeline。</p>
<p>优化后的AST可以转换为IR（比如LLVM<a href="#refer-2"><sup>2</sup></a> IR），由LLVM进一步优化，并生成后端代码。如果是添加新后端并且复用LLVM，需要实现对应Codegen逻辑。AST也可以不借助LLVM，直接编写codegen逻辑生成不同层级的code或指令。</p>
<p>随着深度学习模型越来越复杂，在生产中广泛使用，对计算性能和成本的需求日趋强烈，深度学习编译器在这样的背景下逐步发展壮大。</p>
<p>在深度学习编译器提出前，广泛使用的优化方法是手工fuse和手工codegen。但这样的劣势显而易见，模型中可能存在的子图pattern千奇百怪，并且各种自定义长尾算子层出不求，如果一直依靠手工优化，开发时间和人力成本都不太能令人接受。</p>
<p>因此，借鉴传统编译器的思路，通过有限的基础表达符号表示任意计算图结构，由编译器的codegen层统一做后端代码生成。</p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>编译器根据编译发生时间的不同可以分为AOT<a href="#refer-3"><sup>3</sup></a>（Ahead Of Time）和JIT<a href="#refer-4"><sup>4</sup></a>（Just In Time）。</p>
<p>AOT编译通常用于standalone编译程序，由用户提前运行编译生成指令，并传输到运行设备上（非标设备/专用设备，比如ARM和定制NPU），通过runtime执行。</p>
<p>一次编译，到处运行，这允许AOT编译消耗更多的时间，探索更优结果，但也限制了灵活性。每当模型发生改动就需要触发一次编译行为，通常编译设备和运行设备是分立的，指令文件和runtime版本的同步会更复杂。</p>
<p>JIT在运行时条件触发编译，runtime和compiler捆绑，不存在版本不匹配的问题。JIT通常见于解释型程序，因为解释效率通常低于编译，通过运行前编译提高执行效率。</p>
<p>由于在运行时编译，编译时间相对运行时间必须要合理，这意味着不能引入过于复杂的优化逻辑，另外为了避免重复编译，可以加入cache（程序内/远程）提高效率。</p>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><p>编译器前端需要读取各个框架的模型文件，比如Tensorflow的SavedModel或者PyTorch的TorchScript。</p>
<p>也有试图将模型表达统一的工作出现，比如ONNX，试图在Caffe、PyTorch、MXNet等框架间构建转换桥梁。愿景很好，方便用户在不同框架迁移，不被框架锁死，但最终没有被大规模使用。</p>
<p>首先，Tensorflow出自Google，并不买账，ONNX是其他大公司的联盟产物，然而框架上只有PyTorch不断发展，和Tensorflow二分天下。</p>
<p>统一模型表达，还是在统一社区，也就是统一算子集。</p>
<p>Tensorflow曾凭借其绝对的垄断地位十分强势，后端软件栈都主动接入，接受Tensorflow的核心算子集为golden标准。然而不同框架的算子集相差很多，基本上只有最主流的算子可以无缝转换，换个复杂的模型很有可能就挂了。尤其是Tensorflow的计算图，控制结构十分复杂，连官方的优化工具都可能出现bug。如果模型定制程度高，不如直接改脚本来的快。</p>
<p>当然对大多数算法工程师来说，没有被框架锁定这件事，只有看哪个框架的生态的轮子能符合业务需求。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>编译优化方法泛指一大类模型优化方法，比如Tensorflow自带的后端XLA，基于profiling搜索的TVM，基于整数线性规划的多面体方法等。</p>
<p>Tensorflow自带的前端计算图优化Grappler也可以算作编译器的优化功能。在图层面执行一般优化方法，比如CSE（公共子表达式消除），Constant Folding（常量折叠），去除无用节点（Dead Nodes）等。</p>
<p>对于硬件后端编译器，主要优化步骤如下：</p>
<ol>
<li>硬件无关优化。</li>
<li>尽可能从子图中匹配更多符合硬件结构的pattern。</li>
<li>匹配可以转换为符合硬件结构pattern的子图，并实现转换逻辑（硬件相关优化），注意功能正确性。</li>
<li>尽量将匹配到的子图融合，使之最大化连通。</li>
<li>设定不连通子图最小阈值，防止主存和硬件内存的context switch开销过高，可以通过算子数量或者算力评估确定阈值，标记所有符合阈值的子图算子。</li>
<li>融合所有标记的子图，生成对应的模型IR或者硬件IR。</li>
<li>可以通过自定义Op的形式，将生成的IR序列化（作为Op参数），使用统一的Op（调用runtime）。</li>
<li>如果模型可以全量支持，则可以直接导出IR，使用runtime运行。</li>
</ol>
<p>进一步的，编译器可以独立为TensorRT的形式，允许用户使用API直接构建运行，并且可以通过JIT codegen dispatch手工优化的code。</p>
<p>编译器相比于计算库更关注图层面优化，底层会协调计算库的不同实现使全局性能最优。</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">Abstract syntax tree</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://llvm.org/" target="_blank" rel="noopener">The LLVM Compiler Infrastructure</a></li>
<li>[3] <span id="refer-3"></span> <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation" target="_blank" rel="noopener">Ahead-of-time compilation</a></li>
<li>[4] <span id="refer-4"></span> <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener">Just-in-time compilation</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 2-1 - 推理优化总览</title>
    <url>/ai/ml-system/inference-optimization/1-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模型推理服务是在业务关键路径上的，其性能足以收到高度重视。如何优化训练后的模型，提高性能，降低资源占用，维持推理精度，优化方法的通用化与自动化，这些是模型推理优化的核心目标。</p>
<a id="more"></a>
<p>说起性能优化，软件的性能优化应该是必备功课，通过profiling定位bottleneck，再针对性优化，可以说具备一定程度通用的方法论，但实际业务上也要随机应变。</p>
<p>模型性能的优化也属于软件性能优化，特点是模型的运行调度框架已经确定，并且由社区平衡通用性和性能做了不少的优化。</p>
<p>模型性能的问题主要在低效的计算密集型算子，不合理的子图结构，复杂的动态运行环境，冗余的模型结构和数据宽度。</p>
<p>针对这些问题，模型推理优化方法主要分为：</p>
<h1 id="计算图结构优化"><a href="#计算图结构优化" class="headerlink" title="计算图结构优化"></a>计算图结构优化</h1><p>主要是清理冗余节点，一般的训练节点，框架在开始运行前会根据输入和输出裁剪无关节点，通常对性能影响不大。</p>
<p>但部分嵌入计算图的节点就很难被去除，Tensorflow引入的控制结构就是是图结构优化点之一，比如训练时需要的随机dropout结构等，用户可能在构建模型时把标记是否是训练的变量加入到计算图，在清理时就需要将对应placeholder转变为常量，提取子图。</p>
<h1 id="算子融合"><a href="#算子融合" class="headerlink" title="算子融合"></a>算子融合</h1><p>主要是融合子图，比如对于Feature Embedding这类常用的特征预处理API，通常为了灵活性，生成的子图比较复杂，算子数量极多，框架调度算子的开销远远超过算子实际执行的开销。因此可以匹配对应子图，使用一个算子代替，大大提高执行效率。高频模型中Tensorflow引入的循环控制结构也可以被优化，比如LSTM结构。</p>
<p>通常需要匹配识别的子图较复杂，依赖人工发现模式并编写匹配逻辑，基本纯手工，开发验证工作量大，由于引入了控制节点和Dynamic Shape，目前编译优化方法也没有很好的解法。因此，通常只针对成熟模型做此类定制优化，比如Transformer结构，Embedding结构等。</p>
<h1 id="硬件计算库"><a href="#硬件计算库" class="headerlink" title="硬件计算库"></a>硬件计算库</h1><p>底层硬件开发者出于安全或其他原因考虑，不会开放底层实现细节，也不会开放精细控制接口，但为了迎合市场需求，会推出计算库。</p>
<p>计算库内提供了粗粒度的算子接口，内置了不少汇编层级的优化经验，实现方法至于是if else还是JIT codegen就不得而知了。</p>
<p>计算库内的核心是如何高效利用硬件执行矩阵并行计算，通常基于经验，比如考虑Cache大小，内存带宽，数据位宽等，利用一个“经验性”公式计算出合理的矩阵分块配置，比较重要也比较让人感到tricky的是公式中不时出现的magic number，很有可能是结合profiling得出的经验。</p>
<p>常见的计算库比如CUDA和MKL-DNN，在单个算子优化的基础上，硬件厂家还会提供子图层面的计算优化库，比如TensorRT等。</p>
<h1 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h1><p>编译优化包含一大类方法，也借鉴了上述方法的思路。主要目标是自动化地、通用化地实现图结构优化、算子融合、以及矩阵分块。</p>
<p>和编译器的优化思路类似，不同框架的计算图经过分图，将可编译的子图会被统一转化为编译优化框架的中间表示（IR），再通过一系列的通用的编译优化pass得到优化后的IR，随后codegen生成执行代码。只要能被划分进编译子图，就能通用化地支持图结构优化和算子融合。</p>
<p>最精华的地方在于codegen，主要思路有：</p>
<ul>
<li>写入人工调优的经验，生成高效的底层执行代码。一般是社区早期这么做，比如Tensorflow的XLA。</li>
<li>借用硬件计算库生成高效代码。硬件厂商这头大象终于反应过来了，毕竟他们对硬件更了解，不用白不用。</li>
<li>把硬件当作黑盒，构建细粒度矩阵分块方法，通过profiling不断调整分块参数，直到收敛到最优解。比较暴力，分块方法的可调参数越多，Tuning（参数搜索）的时间可能越长，不过也有算法加速收敛，比如TVM。</li>
<li>解析法，比如Ployhedral，把矩阵分块过程描述为一般的空间变换方法，而性能优化问题就转化成了搜索最优整数解的过程。愿景很好，但目标函数本身又很难和实际硬件完全对应，搜索的时间也不小。</li>
</ul>
<p>编译优化方法在学术届内百花齐放，本质上还是新瓶装旧酒，关键还是在于如何把新问题转化为通用的老问题，并解决新的问题定义边界带来的新的约束带来的corner case。</p>
<p>对于主流模型，硬件厂商的人力可以做到全图支持，定制优化的性能让编译优化难以超越，编译优化更多地是在通用化的corner case场景下发挥作用，与手工方法互补。</p>
<p>同时现有的编译优化方法本身也会遇到比如Dynamic Shape的问题，严重影响分图和codegen，亟待解决。好在如MLIR等编译基础设施工作正在不断发展，解决多层IR信息联合优化，复用优化pass，解决共有的问题。</p>
<h1 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h1><p>除了编译优化方法之外，模型压缩也被用来从算法层面去除降低数据位宽，冗余图结构，大幅并行化模型结构。</p>
<ul>
<li>量化</li>
</ul>
<p>模型推理的性能问题有很多是memory bound（受限于内存带宽），尤其是在高度密集计算（大batch）的场景下，同时推理相对于训练不需要很高的数据精度，可以使用量化方法缩减数据位宽，直接降低所需内存带宽，memory bound问题也迎刃而解。同时原来用于计算32位数据（FP32）的计算单元可以配置为计算2个16位数据（FP16）和4个8位数据（INT8），计算性能也直接翻番。</p>
<ul>
<li>剪枝</li>
</ul>
<p>深度学习模型并不是要求精确计算，而是计算概率分布，因此在实践中，将模型中权重较小的连接直接置为0或去除，对模型的整体精度影响不大，反而有效降低了总体计算量。</p>
<ul>
<li>蒸馏</li>
</ul>
<p>出于直观，可能使用串行结构（数据依赖）模型，导致计算效率不高，或者使用超大模型，模型参数非常多。但模型训练本质上是拟合数据的目标概率分布，那么就可以使用另一个并行模型“学习”串行模型的概率分布，或者使用一个小模型“学习”大模型的概率分布。只要模型精度控制在预期范围内，那么所需的计算量就能大幅下降。</p>
<h1 id="推理服务性能优化"><a href="#推理服务性能优化" class="headerlink" title="推理服务性能优化"></a>推理服务性能优化</h1><p>这部分和模型关系不大，但也在关键路径上，因此放在这里。服务的性能优化，主要是优化数据链路，比如数据传输协议，Serving框架线程性能，网关性能等。</p>
<hr>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 2-2 - 图优化</title>
    <url>/ai/ml-system/inference-optimization/2-graph-optimization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图结构优化在算子层面调整图结构，调整前后的计算图输入输出等价。</p>
<a id="more"></a>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>图层面优化主要包括：</p>
<h2 id="训练图清理"><a href="#训练图清理" class="headerlink" title="训练图清理"></a>训练图清理</h2><p>主要针对TensorFlow 1.x， Tensorflowd的训练图包含较多非推理用算子，通常调用TF提供的API提取子图，但可能因为用户的构图不当不能被清理干净。常见的操作包括：</p>
<ul>
<li>固定输入Placeholder替换为Const，使TF API去除更多算子</li>
<li>根据用户输入输出设置保护Node，尽可能多地剔除冗余算子，并且防止提取子图后出错</li>
<li>通过对SavedModel的Metagraph API精细剔除仅在训练图中存在的自定义Op</li>
<li>去除训练用Switch Merge结构，比如训练用的Dropout结构</li>
</ul>
<h2 id="子图优化"><a href="#子图优化" class="headerlink" title="子图优化"></a>子图优化</h2><p>主要是图结构的局部优化，常见操作包括：</p>
<ul>
<li>使用常见的优化操作，比如CSE（Common Subexpression Elimination） ，常量折叠Constant Folding等</li>
<li>图结构等价变换，适配硬件指令，比如拆分卷积，重排数据Layout，卷积转矩阵乘等</li>
<li>常量Propagation，加强的常量折叠，更大范围地支持折叠某些固定输入算子</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>针对高频使用的子图模式做专项优化，常见模式包括：</p>
<ul>
<li>BatchNorm，融合乘加操作，社区框架已支持</li>
<li>ResNet Block，Conv-Bias-BatchNorm，更激进的融合，社区框架已支持</li>
<li>Transformer，Multi-Head Attention</li>
<li>Feature Column Embedding，调度开销高于计算开销，算子融合即可带来收益，底层可使用MKL加速。</li>
<li>LSTM</li>
</ul>
<h2 id="算子改写"><a href="#算子改写" class="headerlink" title="算子改写"></a>算子改写</h2><p>针对不同的计算场景，针对性地修改算子实现，实现统一框架对模型性能的覆盖程度。</p>
<ul>
<li>启发式，根据硬件的结构参数优化计算，比如指令位宽，Cache Line大小等，但通常可能会引入经验值，手工搜索后得到性能较均衡的magic number。</li>
<li>三方库，比如MKL，CUDA或其他硬件厂商提供的计算库，但要注意线程冲突，内存带宽不匹配等问题。</li>
<li>特定指令优化，根据专用硬件后端，比如定制NPU，Intel CPU的VNNI INT8和BF16指令定制算子实现。</li>
</ul>
<p>图结构优化通过去除冗余算子优化模型的推理性能，一是减少了不必要的计算，二是减少了不必要的调度开销。</p>
<p>尤其是算子定制，可以通过手工编写算子达到理想的计算性能，针对高频子图模式最有效，但对于业务模型变种，缺乏灵活性，手工支持的响应时间较长，维护成本较高。</p>
<p>在此基础上，编译优化正是标准化自动化的优化方法。</p>
<hr>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 2-3 - 编译优化</title>
    <url>/ai/ml-system/inference-optimization/3-compilation-optimization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深度学习的编译优化方法师承程序语言，相比而言，程序语言的输入是语法树，深度学习的输入是计算图，有相似的编译结构，深度学习后端可以借鉴LLVM架构灵活支持新后端硬件。</p>
<a id="more"></a>
<p>不少社区都提出了自己的编译优化框架，定义了自己的一套中间表达（IR，Intermediate Represent），在发展过程中，这些框架和IR也在相互借鉴相互融合。</p>
<h1 id="XLA"><a href="#XLA" class="headerlink" title="XLA"></a>XLA</h1><p>XLA(Accelerated Linear Algebra)是TensorFLow给出的编译优化框架，嵌入在Tensorflow的图层面的Grappler优化中，提供了子图划分，IR转换，Codegen(代码生成)等功能，属于JIT(Just-In-Time)流程。</p>
<p>XLA定义一套Tensorflow算子集的子集Instruction，在IR转换阶段将Tensorflow的算子转换为等价表达，随后执行编译优化以及Codegen。</p>
<p>对于通用计算硬件，能在子图划分阶段进入候选集的算子基本都能完成整套编译优化流程，XLA后端将XLA Instruction转换为LLVM IR使用LLVM生成代码，能做到较好的模型覆盖。</p>
<p>但对于专用硬件，一是支持的算子较少，分割的子图大小和数量都较多，会引入较高的跨设备调度开销，通常会设定编译触发阈值，二是支持的子图pattern受限，纯粹使用算子集划分子图，后端硬件可能不支持，需要fallback回Tensorflow图，或者提前加入图匹配。</p>
<p>但XLA对子图输入Shape敏感，导致每种Shape都会触发一次编译，XLA的编译结果Cache很有可能溢出，尤其是对于输入极不固定的模型，频繁编译会大大影响模型性能，甚至导致负优化。</p>
<p>另一方面，XLA的代码生成仍然是启发式的，不能在指令层面优化，也没有动态搜索，导致XLA在大部分常见场景上不敌手工图优化。</p>
<p>因此，XLA的一个优化方向是使用第三方库负责计算密集型算子的计算，XLA编译机制作为fusion优化，能较好平衡优化性能。</p>
<h1 id="TensorRT"><a href="#TensorRT" class="headerlink" title="TensorRT"></a>TensorRT</h1><p>TensorRT是NVIDIA提供的一套独立的模型构建工具，提供了算子级别的API，用户可以用来直接构建计算图，并提供了转换工具将框架的模型文件转换为Tensor RT的执行参数。</p>
<p>同时，TensorRT也在图层面用和XLA类似的方法接入了TensorFlow，TensorRT内部负责优化子图和生成GPU kernel。</p>
<h1 id="OpenVINO"><a href="#OpenVINO" class="headerlink" title="OpenVINO"></a>OpenVINO</h1><p>OpenVINO是Intel提供的一套独立的模型构建工具，并提供了转换工具执行全图转换，支持的算子的覆盖度有待提高。内部应该也是基于OneDNN（原MKL-DNN）提供的构建接口。</p>
<h1 id="TVM"><a href="#TVM" class="headerlink" title="TVM"></a>TVM</h1><p>TVM的主要思想是搜索计算密集型算子的所有可调的参数空间，比如循环展开的基本宽度（可能影响Cache），循环顺序（可能影响分块逻辑），数据Layout等。</p>
<p>TVM使用TVM IR定义了基本操作，可以直接通过TVM IR描述某个计算密集型算子的计算结构，使用Schedule定义在计算结构上搜索(Tuning)的空间。</p>
<p>在计算图层面，TVM定义了一套Relay IR作为计算图层面的表达，各个框架的算子可以转换为Relay IR，再统一优化，执行fusion等操作。</p>
<p>可以通过XLA接入Tensorflow。</p>
<h1 id="PolyHydral"><a href="#PolyHydral" class="headerlink" title="PolyHydral"></a>PolyHydral</h1><p>多面体优化，TVM所使用的方法来源，但更侧重于使用数学方法启发式地寻找最优解，结合少量Profiling，定义每套硬件的启发参数。</p>
<h1 id="MLIR"><a href="#MLIR" class="headerlink" title="MLIR"></a>MLIR</h1><p>MLIR旨在统一多种框架的多层IR，共享优化方法，并将图信息跨IR保留，解决Dynamic Shape的问题。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 2-4 - 模型压缩</title>
    <url>/ai/ml-system/inference-optimization/4-model-compression/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模型压缩相比图优化/编译优化无损优化方法，侧重减少网络参数量，达到节约服务器资源，端侧部署优化等目的。</p>
<a id="more"></a>
<h1 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h1><p>如矩阵分解（Factor Machine），权值共享（CNN），分组卷积（MobileNet的depth-wise Conv)，分拆卷积（Inception）等。</p>
<p>结构优化主要是模型结构创新，以更少的计算量/模型参数达到相似的模型准确度。</p>
<h1 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h1><p>使用高精度浮点训练，使用定点推理。常见量化格式有FP16，BF16，INT8，INT4。</p>
<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p>剪枝按粒度可分为突触剪枝、神经元剪枝、权重矩阵剪枝等。</p>
<p>基本思想是将接近0的参数置为0，通过稀疏矩阵存储。</p>
<p>首先训练一个精度较高的大模型，按阈值置0，随后在训练集上微调，验证模型大小和精度是否符合预期，否则持续迭代。</p>
<h1 id="蒸馏"><a href="#蒸馏" class="headerlink" title="蒸馏"></a>蒸馏</h1><p>蒸馏过程是对Student和Teacher的拟合，老师和学生可以使用不同的网络结构（串行到并行），不同规模的参数（减少模型参数）。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 2-5 - 系统级优化</title>
    <url>/ai/ml-system/inference-optimization/5-system-level-optimization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>推理优化除了对模型本身的优化，还需要考虑计算框架、推理服务等系统层面的优化。</p>
<a id="more"></a>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ul>
<li>编译器优化</li>
<li>线程并行</li>
<li>Cache优化</li>
<li>Memory</li>
<li>稀疏化</li>
<li>内存精细管理</li>
<li>专用指令，比如ARM的NEON、Intel的AVX</li>
<li>亲核性，NUMA</li>
</ul>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><ul>
<li>线程/进程/服务实例并行</li>
<li>调度绑定</li>
<li>资源复用</li>
<li>网络开销</li>
<li>缓存</li>
<li>延时抖动</li>
<li>服务稳定性</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-1 - 推荐系统总览</title>
    <url>/ai/ml-system/recommender/1-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>推荐系统主要用来根据用户行为数据/用户特征实现个性化体验，行为预测，提高点击率/转化率等关键商业指标。</p>
<a id="more"></a>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p>数据很大程度上决定了模型的效果上限，通过特征工程构造合适的特征对效果有举足轻重的影响。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>推荐系统的功能模块主要包括：</p>
<ul>
<li>召回</li>
</ul>
<p>从全量候选物品中全选一小部分，规模在千/万级别。对<strong>运行速度</strong>要求高，通常使用传统机器学习算法或自定义规则。可以搭配使用多种召回方法。召回物品经过滤过滤去重送往下个模块。</p>
<ul>
<li>排序</li>
</ul>
<p>对召回物品打分拍排序，可以使用更复杂的模型，加入更多特征，更精准的排序。对<strong>模型精度</strong>要求高，通常使用深度学习方法。排序可细化为粗排，精排和重排三个步骤。</p>
<ul>
<li>粗排</li>
</ul>
<p>当召回物品数量过多，或者排序模型比较复杂时，会使用相对简单的模型对召回物品粗略排序筛选，进一步降低物品数量。</p>
<ul>
<li>精排</li>
</ul>
<p>主要排序步骤，会尽可能使用复杂的模型和足够的特征提高模型精度。</p>
<ul>
<li>重排</li>
</ul>
<p>通常用于进一步调整，比如固定物品插入，多样性保证等。</p>
<ul>
<li>AB测试</li>
</ul>
<p>AB测试系统用来线上衡量模型的效果，通常分为App，Domain(Scene)，(Lab)，Layer，(Conditional Layer)，Experiment(Bucket)等。</p>
<h1 id="外围辅助"><a href="#外围辅助" class="headerlink" title="外围辅助"></a>外围辅助</h1><p>推荐系统除了核心的算法模块外，还需要外围存储和计算系统的支持，可以包括：</p>
<ul>
<li>离线数仓</li>
</ul>
<p>以Hive/MaxCompute为代表，用于离线数据批处理，处理后的数据通常放在KV存储中供实时访问，通常以小时或天更新。</p>
<ul>
<li>实时数仓</li>
</ul>
<p>以HBase/Hologres为代表，用于实时特征访问。</p>
<ul>
<li>关系型数据库</li>
</ul>
<p>以MySQL，PostgreSQL为代表，用于存储小规模数据，存取速度较快。</p>
<ul>
<li>KV缓存数据库</li>
</ul>
<p>以Redis为代表，存储提前计算好的映射表，可设置失效时间，内存缓存读速度最快。</p>
<ul>
<li>大数据计算引擎</li>
</ul>
<p>以Spark，Flink为代表，执行批量数据处理和传统机器学习算法，可用于召回阶段。</p>
<ul>
<li>深度学习模型引擎</li>
</ul>
<p>以Tensorflow，PyTorch为代表，提供更复杂的深度学习模型服务。</p>
<ul>
<li>搜索索引引擎</li>
</ul>
<p>以ElasticSearch为代表，按条件索引速度较快。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-10 - 因子分解机</title>
    <url>/ai/ml-system/recommender/10-factor-machine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因子分解机</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li>FM能处理数据高度稀疏场景，SVM则不能；</li>
<li>FM具有线性的计算复杂度，而SVM依赖于support vector。</li>
<li>FM能够在任意的实数特征向量中生效。</li>
</ol>
<p>—</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-11 - 树模型</title>
    <url>/ai/ml-system/recommender/11-tree/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树模型以决策树为基本原型。</p>
<a id="more"></a>
<p>树模型<a href="#refer-5"><sup>5</sup></a> <a href="#refer-6"><sup>6</sup></a></p>
<h2 id="DT"><a href="#DT" class="headerlink" title="DT"></a>DT</h2><p>决策树是一种基本的分类和回归方法。和我们之前学过的逻辑斯特回归，线性回归等算法不同，他们要么只能做回归要么只能做分类，而决策树既可以做分类也可以做回归。主要包括：ID3，C4.5，CART。</p>
<p>物理含义：表示定义在特征空间上的条件概率分布，也就是把<script type="math/tex">P(y)</script>转化为<script type="math/tex">P(y|X)</script>。同时也可以理解为 if-then 规则的集合。如下图左图所示。</p>
<p>几何含义： “分而治之”的思想，即把特征空间划分为一系列的矩形区域，然后再每一个区域拟合一个简单的模型。如下图右图所示。本文将用决策树的几何含义对决策树进行讲解。</p>
<h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>原因：<br>在决策树构建的过程中，对决策树的生长没有进行合理的限制（剪枝）；<br>样本中有一些噪声数据，没有对噪声数据进行有效的剔除；<br>在构建决策树过程中使用了较多的输出变量，变量较多也容易产生过拟合。<br>解决办法：<br>选择合理的参数进行剪枝，可以分为预剪枝和后剪枝，我们一般采用后剪枝的方法；<br>利用K−folds交叉验证，将训练集分为K份，然后进行K次交叉验证，每次使用K−1份作为训练样本数据集，另外一份作为测试集；<br>减少特征，计算每一个特征和响应变量的相关性，常见得为皮尔逊相关系数，将相关性较小的变量剔除；当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等（决策的正则化，例如，L1和L2正则，具体是对谁的正则呢？怎样正则的呢？）。</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>预剪枝：在决策树生成初期就已经设置了决策树的参数，决策树构建过程中，满足参数条件就提前停止决策树的生成。<br>后剪枝：后剪枝是一种全局的优化方法，它是在决策树完全建立之后再返回去对决策树进行剪枝。<br>参数：树的高度、叶子节点的数目、最大叶子节点数、限制不纯度。</p>
<p>预剪枝使得决策树的很多分支都没有“展开”，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间开销。但是，另一方面，因为预剪枝是基于“贪心”的，所以，虽然当前划分不能提升泛华性能，但是基于该划分的后续划分却有可能导致性能提升，因此预剪枝决策树有可能带来欠拟合的风险。</p>
<p>后剪枝决策树通常比预剪枝决策树保留了更多的分支，一般情形下，后剪枝决策树的欠拟合风险小，泛华性能往往也要优于预剪枝决策树。但后剪枝过程是在构建完全决策树之后进行的，并且要自底向上的对树中的所有非叶结点进行逐一考察，因此其训练时间开销要比未剪枝决策树和预剪枝决策树都大得多。</p>
<ul>
<li>REP-错误率降低剪枝</li>
<li>PEP-悲观剪枝<a href="#refer-13"><sup>13</sup></a></li>
<li>CCP-代价复杂度剪枝<a href="#refer-13"><sup>13</sup></a></li>
</ul>
<p>后剪枝会减少欠拟合的风险，但训练时间相对于预剪枝会长很多。</p>
<p>REP方法是通过一个新的验证集来纠正树的过拟合问题。对于决策树中的每一个非叶子节点的子树，我们将它替换成一个叶子节点，该叶子节点的类别用大多数原则来确定，这样就产生了一个新的相对简化决策树，然后比较这两个决策树在验证集中的表现。如果新的决策树在验证集中的正确率较高，那么该子树就可以替换成叶子节点，从而达到决策树剪枝的目的。该算法是从下往上依次遍历所有的子树，直至没有任何子树可以替换使得在验证集上的表现得以改进时，算法就可以终止。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>ID3以信息增益作为特征划分依据。信息增益表示由于得知特征a的信息后儿时的数据集D的分类不确定性减少的程度，后面部分越小,减小的程度越小,增益越大。选择划分后信息增益大的作为划分特征，说明使用该特征后划分得到的子集纯度越高，即不确定性越小。因此我们总是选择当前使得信息增益最大的特征来划分数据集。缺点是信息增益偏向取值较多的特征（原因：当特征的取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分后的熵更低，即不确定性更低，因此信息增益更大）</p>
<p>C4.5以信息增益率作为特征划分依据。可以利用连续特征，同时还增加了处理缺失值的方法和剪枝。需要注意的是，C4.5使用信息增益比对特征进行选择又会出现对特征取值较少的特征有偏好的问题。因此 C4.5 并不是直接用增益率最大的特征进行划分，而是使用一个启发式方法：先从候选划分特征中找到信息增益高于平均值的特征，再从中选择增益率最高的。C4.5处理连续特征方法是首先对连续特征进行排序，然后选择相邻值得中点作为分割点，需要注意的是，C4.5处理连续值是二分，并且该连续特征在接下来也可以继续使用。其余就和处理离散特征没有太大的区别了。</p>
<p>CART以基尼系数作为特征划分依据。无论是 ID3 还是 C4.5 都会涉及大量的对数运算。CART 分类树算法使用基尼系数，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。</p>
<script type="math/tex; mode=display">
Gini(p) = \sum_{k=1}^{K} p_{k} (1-p_{k}) = 1 - \sum_{k=1}^{K} p_{k}^2</script><p>如果是二类分类问题，计算就更加简单了，如果属于第一个样本输出的概率是 p，则基尼系数的表达式为：</p>
<script type="math/tex; mode=display">
Gini(p) = 2p(1 - p)</script><p>对于个给定的样本D，假设有 K 个类别, 第 k 个类别的数量为 <script type="math/tex">C_{k}</script> ,则样本 D 的基尼系数表达式为：</p>
<script type="math/tex; mode=display">
Gini(D) = 1 - \sum_{k=1}^{K} (\frac{|C_k|}{|D|})^2</script><p>特别的，对于样本 D，如果根据特征 A 的某个值 a，把 D 分成 D1 和 D2 两部分，则在特征 A 的条件下，D 的基尼系数表达式为：</p>
<script type="math/tex; mode=display">
Gini(D|A) = \frac{|D_1|}{|D|}Gini(D_1) + \frac{|D_2|}{|D|}Gini(D_2)</script><ul>
<li>采用基尼系数可以降低计算量</li>
<li>连续值处理：其思想和 C4.5 是相同的，都是将连续的特征离散化。唯一的区别在于在选择划分点时的度量方式不同，C4.5 使用的是信息增益比，则 CART 分类树使用的是基尼系数。</li>
<li>采用二叉树：ID3 或者 C4.5采用的是多叉树；CART树采用的是二叉树。在 ID3 或者 C4.5 的一棵子树中，离散特征只会参与一层节点的建立；CART树中离散的特征可能参与多层节点的建立。</li>
</ul>
<h2 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h2><p>随机森林是集成学习中的Bagging方法。提到随机森林，就不得不提Bagging，Bagging可以简单的理解为：放回抽样，多数表决（分类）或简单平均（回归）,同时Bagging的基学习器之间属于并列生成，不存在强依赖关系。</p>
<p>Random Forest（随机森林）是Bagging的扩展变体，它在以决策树 为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择，因此可以概括RF包括四个部分：1、随机选择样本（放回抽样）；2、随机选择特征；3、构建决策树；4、随机森林投票（平均）。 </p>
<p>RF和Bagging对比：RF的起始性能较差，特别当只有一个基学习器时，随着学习器数目增多，随机森林通常会收敛到更低的泛化误差。随机森林的训练效率也会高于Bagging，因为在单个决策树的构建中，Bagging使用的是‘确定性’决策树，在选择特征划分结点时，要对所有的特征进行考虑，而随机森林使用的是‘随机性’特征数，只需考虑特征的子集。</p>
<h2 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h2><p>GBDT是集成学习中的Boosting方法。提GBDT之前，谈一下Boosting，Boosting是一种与Bagging很类似的技术。不论是Boosting还是Bagging，所使用的多个分类器类型都是一致的。但是在前者当中，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练的分类器的性能来进行训练。Boosting是通过关注被已有分类器错分的那些数据来获得新的分类器。 </p>
<p>GBDT与传统的Boosting区别较大，它的每一次计算都是为了减少上一次的残差，而为了消除残差，我们可以在残差减小的梯度方向上建立模型,所以说，在GradientBoost中，每个新的模型的建立是为了使得之前的模型的残差往梯度下降的方法，与传统的Boosting中关注正确错误的样本加权有着很大的区别。 </p>
<p>在GradientBoosting算法中，关键就是利用损失函数的负梯度方向在当前模型的值作为残差的近似值，进而拟合一棵CART回归树。 </p>
<p>GBDT的会累加所有树的结果，而这种累加是无法通过分类完成的，因此GBDT的树都是CART回归树，而不是分类树（尽管GBDT调整后也可以用于分类但不代表GBDT的树为分类树）。</p>
<p>GBDT的性能在RF的基础上又有一步提升，因此其优点也很明显，1、它能灵活的处理各种类型的数据；2、在相对较少的调参时间下，预测的准确度较高。 </p>
<p>当然由于它是Boosting，因此基学习器之前存在串行关系，难以并行训练数据。</p>
<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>XGBoost的性能在GBDT上又有一步提升，而其性能也能通过各种比赛管窥一二。坊间对XGBoost最大的认知在于其能够自动地运用CPU的多线程进行并行计算，同时在算法精度上也进行了精度的提高。 </p>
<p>由于GBDT在合理的参数设置下，往往要生成一定数量的树才能达到令人满意的准确率，在数据集较复杂时，模型可能需要几千次迭代运算。但是XGBoost利用并行的CPU更好的解决了这个问题。 </p>
<p>其实XGBoost和GBDT的差别也较大，这一点也同样体现在其性能表现上，详见XGBoost与GBDT的区别。</p>
<ul>
<li>与GBDT的区别</li>
</ul>
<p>传统的GBDT以CART树作为基学习器，XGBoost还支持线性分类器，这个时候XGBoost相当于L1和L2正则化的逻辑斯蒂回归（分类）或者线性回归（回归）；传统的GBDT在优化的时候只用到一阶导数信息，XGBoost则对代价函数进行了二阶泰勒展开，得到一阶和二阶导数；</p>
<p>XGBoost在代价函数中加入了正则项，用于控制模型的复杂度。从权衡方差偏差来看，它降低了模型的方差，使学习出来的模型更加简单，放置过拟合，这也是XGBoost优于传统GBDT的一个特性；shrinkage（缩减），相当于学习速率（XGBoost中的eta）。XGBoost在进行完一次迭代时，会将叶子节点的权值乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。（GBDT也有学习速率）；</p>
<p>列抽样。XGBoost借鉴了随机森林的做法，支持列抽样，不仅防止过 拟合，还能减少计算；</p>
<p>对缺失值的处理。对于特征的值有缺失的样本，XGBoost还可以自动 学习出它的分裂方向；</p>
<p>XGBoost工具支持并行。Boosting不是一种串行的结构吗？怎么并行的？注意XGBoost的并行不是tree粒度的并行，XGBoost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。XGBoost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），XGBoost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代 中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</p>
<hr>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-11 - 深度模型</title>
    <url>/ai/ml-system/recommender/12-deep-model/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深度模型主要是在深度学习后崛起的，主要通过深度学习网络做了自动特征交叉。</p>
<a id="more"></a>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><ul>
<li>Wide&amp;Deep</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-2 - 特征工程</title>
    <url>/ai/ml-system/recommender/2-feature-engineer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>特征工程是利用数据的特定领域知识构建特征使算法达到最高性能的过程。</p>
<a id="more"></a>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>特征工程通常包含特征提取、特征选择、特征构建等三个子过程。</p>
<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>自动构建新特征，将原始特征转换为一组具有明显物理意义或统计意义的特征。比如PCA，ICA，LDA等，推荐系统中常用特征构建。</p>
<h2 id="特征构建"><a href="#特征构建" class="headerlink" title="特征构建"></a>特征构建</h2><p>特征构建是指从原始数据中人工地构造新的特征，需要对结合使用场景和数据样本分析构建。</p>
<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h2><p>特征选择的目的是从特征集合中选一组最具统计意义的特征子集，从而达到降维的效果。常用的方法包括：filter、wrapper、embedded。</p>
<ul>
<li>Filter法使用一些评价指标计算单个特征和类别变量之间的关系，如Pearson相关系数，Gini-Index（基尼系数），IG（信息增益）等，选择某个子集作为特征子集（比如从高到低排名的前10%)，使用子集的特征训练，评估模型性能，或者绘制子集和精度的相关图，寻找性能最好的一组特征。优点是计算高效，对过拟合有较高的鲁棒性。缺点是倾向于选择冗余的特征，不考虑特征间的相关性。</li>
<li>Wrapper本质上是分类器，使用选取的特征子集对样本集分类，分类精度作为特征子集优劣的衡量标准，常用的有逐步回归（Stepwise Regression）、向前选择（Forward Selection）和向后选择（Backward Selection）。优点是考虑了特征间的相关性，缺点是数据较少时容易过拟合，特征较多时计算时间长。</li>
<li>Embedded是自主选择特征，如使用Regularization做特征选择，或者用决策树思想，比如Random Forest和Gradient Boosting。</li>
</ul>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="数值特征（Numerial）"><a href="#数值特征（Numerial）" class="headerlink" title="数值特征（Numerial）"></a>数值特征（Numerial）</h3><ul>
<li>标准化与归一化。归一化将数据按比例缩放，使得不同单位/量级的特征间具有可比性。</li>
</ul>
<p>归一的常用方法：</p>
<ol>
<li><p>线性函数归一化，<script type="math/tex">X_{max}</script>、<script type="math/tex">X_{min}</script>分别为数据的最大值和最小值，映射到[0, 1]。</p>
<script type="math/tex; mode=display">X_{norm} = \frac{X-X_{min}}{X_{max}-X_{min}}</script></li>
<li><p>零均值归一化，假设原始数据均值为<script type="math/tex">\mu</script>，标准差为<script type="math/tex">\sigma</script>，映射到均值为0，标准差为1的分布上。</p>
<script type="math/tex; mode=display">z=\frac{x-\mu}{\sigma}</script></li>
</ol>
<ul>
<li>分桶后onehot。</li>
</ul>
<p>等距分桶、等频分桶。</p>
<ul>
<li>缺失值处理。使用均值、中位数、众数代替，也可以直接忽略，将缺失当作一种信息编码。</li>
<li>GBDT模型。LightBGM、XGBoost。</li>
</ul>
<h3 id="类别特征（Categorical）"><a href="#类别特征（Categorical）" class="headerlink" title="类别特征（Categorical）"></a>类别特征（Categorical）</h3><ul>
<li>One-Hot Encoding。通常用于处理类别间不具有大小关系的特征。当类别数量较多时，特征空间会非常大。</li>
<li>Hash Encoding。将原始高维向量压缩成低维向量，且尽量不损失原始特征的表达能力。</li>
<li>Ordinal Encoding。序号编码通常用于处理类别间具有大小关系的数据。</li>
<li>Binary Encoding。用二进制编码，比One-Hot少很多，本质上属于Hash。</li>
</ul>
<h3 id="Embdedding特征"><a href="#Embdedding特征" class="headerlink" title="Embdedding特征"></a>Embdedding特征</h3><h3 id="Context特征"><a href="#Context特征" class="headerlink" title="Context特征"></a>Context特征</h3><p>用户授权的前提下拿到的客户端带的信息，比如请求时间，手机品牌，型号，操作系统，网络状态，用户渠道等。</p>
<h3 id="Session行为特征"><a href="#Session行为特征" class="headerlink" title="Session行为特征"></a>Session行为特征</h3><p>基于用户行为流水，常见划分方法包括：</p>
<ul>
<li>固定行为数窗口，如最近100条行为中的行为统计。</li>
<li>固定时间窗口，如1/3/7/15天内的有过正向行为的item id或同级量。</li>
<li>连续行为窗口，如从打开到关闭App期间的互动行为。</li>
</ul>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。</p>
<p>当两个特征的数量较多时，可以矩阵分解为k维的低维向量表示。</p>
<script type="math/tex; mode=display">Y=sigmoid(\sum_{i}\sum_{j}w_{ij}<x_{i}, x_{j}>)</script><p>可以通过梯度提升决策树（GBDT）寻找有效的特征组合，该方法的思想是每次都在之前构建的决策树的残差上构建下一棵决策树。</p>
<h1 id="典型"><a href="#典型" class="headerlink" title="典型"></a>典型</h1><h2 id="商品推荐"><a href="#商品推荐" class="headerlink" title="商品推荐"></a>商品推荐</h2><h2 id="游戏推荐"><a href="#游戏推荐" class="headerlink" title="游戏推荐"></a>游戏推荐</h2><h2 id="视频推荐"><a href="#视频推荐" class="headerlink" title="视频推荐"></a>视频推荐</h2><h2 id="新闻推荐"><a href="#新闻推荐" class="headerlink" title="新闻推荐"></a>新闻推荐</h2>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-3 - 特征嵌入(Embedding)</title>
    <url>/ai/ml-system/recommender/3-feature-embedding/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Embedding是高维向量到低维空间的转换。在理想情况下，嵌入可以将语义上相似的不同输入映射到嵌入空间里的邻近处，以此来捕获输入的语义<a href="#refer-1"><sup>1</sup></a>。</p>
<a id="more"></a>
<p>在常见的特征中，通常可以用分桶或OneHot编码转为特征，对于类别较多的特征或者非结构化特征，可以通过Embedding转换为紧凑的实值特征向量表示。</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>词嵌入（Word Embedding）将每个单词表示为密集向量，嵌入的相似句子应该在空间上彼此接近。常用模型有神经网络模型（NNLM）、用于字词表示的全局向量（GloVe）、深层语境化词表示（ELMo）、Word2Vec等。</p>
<h3 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h3><p>CBOW</p>
<p>Skip-gram</p>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>使用大型图片数据集训练模型，常用的预训练模型有ResNet、Inception、NasNet、MobileNet等。最后使用不含Softmax分类器的模型作为特征向量，这类向量可以很好的描述图片基本属性。</p>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>可以从高位功率谱密度系数提取特征向量。</p>
<h2 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h2><p>用户和物品数量可能相当大，可以使用矩阵分解、单值分解、神经协同过滤、神经因式分解机等得到向量。物品的嵌入位置表达了物品属性，位置接近的嵌入位置代表用户更相似的兴趣度。</p>
<h3 id="神经协同过滤"><a href="#神经协同过滤" class="headerlink" title="神经协同过滤"></a>神经协同过滤</h3><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>Video2Vec</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>Graph2Vec</p>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://cloud.google.com/architecture/overview-extracting-and-serving-feature-embeddings-for-machine-learning?hl=zh-cn" target="_blank" rel="noopener">概述：提取和提供用于机器学习的特征嵌入  |  云架构中心  |  Google Cloud</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-4 - 召回</title>
    <url>/ai/ml-system/recommender/4-recall/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多种策略混合，快而全</p>
<a id="more"></a>
<h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><h1 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h1><ul>
<li>查表（MySQL）</li>
<li>向量召回</li>
<li><p>Elastic Search</p>
</li>
<li><p>缓存（Redis）</p>
</li>
</ul>
<hr>
<ul>
<li>[1] <span id="refer-1"></span> <a href="https://lumingdong.cn/cooperative-recommendation-algorithms.html" target="_blank" rel="noopener">基于协同的推荐算法</a></li>
<li>[2] <span id="refer-2"></span> <a href="https://blog.csdn.net/GFDGFHSDS/article/details/104775336" target="_blank" rel="noopener">推荐系统之LFM算法详解</a></li>
<li>[3] <span id="refer-3"></span> <a href="https://blog.csdn.net/u012151283/article/details/77716085" target="_blank" rel="noopener">矩阵分解(MF,SVD)和协同过滤(CF)</a></li>
<li>[4] <span id="refer-4"></span> <a href="https://zh.wikipedia.org/zh-hans/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">矩阵分解 - 维基百科</a></li>
<li>[5] <span id="refer-5"></span> <a href="https://blog.csdn.net/jamexfx/article/details/93780308" target="_blank" rel="noopener">推荐系统面试题之机器学习（一）树模型</a></li>
<li>[6] <span id="refer-6"></span> <a href="https://zhuanlan.zhihu.com/p/36335867" target="_blank" rel="noopener">决策树的进化史 - 知乎</a></li>
<li>[7] <span id="refer-7"></span> <a href="https://scikit-learn.org/stable/modules/tree.html" target="_blank" rel="noopener">1.10. Decision Trees — scikit-learn 0.24.2 documentation</a></li>
<li>[8] <span id="refer-8"></span> <a href="https://cuijiahua.com/blog/2017/11/ml_2_decision_tree_1.html" target="_blank" rel="noopener">机器学习实战教程（二）：决策树基础篇之让我们从相亲说起</a></li>
<li>[9] <span id="refer-9"></span> <a href="https://blog.csdn.net/manduner/article/details/90516561" target="_blank" rel="noopener">决策树常见的面试点整理</a></li>
<li>[10] <span id="refer-10"></span> <a href="https://blog.csdn.net/weixin_39946355/article/details/111668238" target="_blank" rel="noopener">l2的最优回归_机器学习（七）：数据预处理—特征选择-L1、L2正则化</a></li>
<li>[11] <span id="refer-11"></span> <a href="https://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="noopener">机器学习中正则化项L1和L2的直观理解</a></li>
<li>[12] <span id="refer-12"></span> <a href="https://blog.csdn.net/sinat_27784071/article/details/84347642" target="_blank" rel="noopener">降低过拟合风险的方法</a></li>
<li>[13] <span id="refer-13"></span> <a href="https://blog.csdn.net/weixin_43216017/article/details/87534496" target="_blank" rel="noopener">决策树的剪枝：REP/PEP/CCP算法</a></li>
<li>[14] <span id="refer-14"></span> <a href="https://easyai.tech/ai-definition/" target="_blank" rel="noopener">AI 知识库</a></li>
<li>[15] <span id="refer-15"></span> <a href="https://cloud.tencent.com/developer/article/1150805" target="_blank" rel="noopener">树算法对比：RF、GBDT、XGBoost</a></li>
<li>[16] <span id="refer-16"></span> <a href="https://zhuanlan.zhihu.com/p/34679467" target="_blank" rel="noopener">RF、GBDT、XGBoost常见面试题整理</a></li>
<li>[17] <span id="refer-17"></span> <a href="https://zhuanlan.zhihu.com/p/348776985" target="_blank" rel="noopener">GBDT理解难点———拟合负梯度</a></li>
<li>[18] <span id="refer-18"></span> <a href="https://www.cnblogs.com/wkang/p/10091790.html" target="_blank" rel="noopener">从零开始学推荐系统一：基于邻域的算法</a></li>
<li>[19] <span id="refer-19"></span> <a href="https://zhuanlan.zhihu.com/p/115690499" target="_blank" rel="noopener">深入理解推荐系统：召回</a></li>
<li>[20] <span id="refer-20"></span> <a href="https://zhuanlan.zhihu.com/p/80068528" target="_blank" rel="noopener">基于内容的推荐算法</a></li>
<li>[21] <span id="refer-21"></span> <a href="https://blog.csdn.net/weixin_42608414/article/details/106502942" target="_blank" rel="noopener">work2vec的实战应用</a></li>
<li>[22] <span id="refer-22"></span> <a href="https://www.cnblogs.com/jielongAI/p/10409463.html" target="_blank" rel="noopener">word2vec是如何工作的？</a></li>
<li>[23] <span id="refer-23"></span> <a href="https://radimrehurek.com/gensim/models/doc2vec.html" target="_blank" rel="noopener">models.doc2vec – Doc2vec paragraph embeddings — gensim</a></li>
<li>[24] <span id="refer-24"></span> <a href="https://zhuanlan.zhihu.com/p/80069337" target="_blank" rel="noopener">协同过滤推荐算法</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-5 - 排序</title>
    <url>/ai/ml-system/recommender/5-rank/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用尽量多且有效的feature排序，准而精</p>
<a id="more"></a>
<h1 id="Wide-amp-Deep"><a href="#Wide-amp-Deep" class="headerlink" title="Wide&amp;Deep"></a>Wide&amp;Deep</h1><h1 id="DeepFM"><a href="#DeepFM" class="headerlink" title="DeepFM"></a>DeepFM</h1>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-6 - AB测试</title>
    <url>/ai/ml-system/recommender/6-ab-test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AB Test</p>
<a id="more"></a>
<ul>
<li>ExperimentRoom</li>
<li>ExperimentLayer</li>
<li>ExperimentGroup</li>
<li>Experiment</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-7 - 基于内容的推荐算法</title>
    <url>/ai/ml-system/recommender/7-content-based/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于内容的推荐算法又叫基于标签的推荐算法，是最早被大规模应用的，思路直观，仍在系统冷启动中发挥作用。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>所谓基于内容的推荐算法(Content-Based Recommendations)是基于标的物相关信息、用户相关信息及用户对标的物的操作行为来构建推荐算法模型，为用户提供推荐服务。这里的标的物相关信息可以是对标的物文字描述的metadata信息、标签、用户评论、人工标注的信息等。用户相关信息是指人口统计学信息(如年龄、性别、偏好、地域、收入等等)。用户对标的物的操作行为可以是评论、收藏、点赞、观看、浏览、点击、加购物车、购买等。基于内容的推荐算法一般只依赖于用户自身的行为为用户提供推荐，不涉及到其他用户的行为。</p>
<p>基于内容的个性化推荐，一般需要三个步骤：</p>
<ol>
<li>基于用户信息及用户操作行为构建用户特征表示</li>
<li>基于标的物信息构建标的物特征表示</li>
<li>基于用户及标的物特征表示为用户推荐标的物</li>
</ol>
<h2 id="基于用户和标的物特征为用户推荐的核心思想"><a href="#基于用户和标的物特征为用户推荐的核心思想" class="headerlink" title="基于用户和标的物特征为用户推荐的核心思想"></a>基于用户和标的物特征为用户推荐的核心思想</h2><ul>
<li>基于用户历史行为记录做推荐</li>
</ul>
<p>我们需要事先计算标的物之间的相似性，然后将用户历史记录中的标的物的相似标的物推荐给用户。</p>
<p>不管标的物包含哪类信息，一般的思路是将标的物特征转化为向量化表示，有了向量化表示，我们就可以通过cosine余弦相似度计算两个标的物之间的相似度了。</p>
<ul>
<li>用户和标的物特征都用显式的标签表示，利用该表示做推荐</li>
</ul>
<p>标的物用标签来表示，那么反过来，每个标签就可以关联一组标的物，那么根据用户的标签表示，用户的兴趣标签就可以关联到一组标的物，这组通过标签关联到的标的物，就可以作为给用户的推荐候选集。这类方法就是所谓的倒排索引法，是搜索业务通用的解决方案。</p>
<ul>
<li>用户和标的物嵌入到同一个向量空间，基于向量相似做推荐</li>
</ul>
<p>当用户和标的物嵌入到同一个向量空间中后，我们就可以计算用户和标的物之间的相似度，然后按照标的物跟用户的相似度，为用户推荐相似度高的标的物。还可以基于用户向量表示计算用户相似度，将相似用户喜欢的标的物推荐给该用户，这时标的物嵌入是不必要的。</p>
<h2 id="基于用户信息及用户操作行为构建用户特征表示"><a href="#基于用户信息及用户操作行为构建用户特征表示" class="headerlink" title="基于用户信息及用户操作行为构建用户特征表示"></a>基于用户信息及用户操作行为构建用户特征表示</h2><p>用户的特征表示可以基于用户对标的物的操作行为(如点击、购买、收藏、播放等)构建用户对标的物的偏好画像，也可以基于用户自身的人口统计学特征来表达。有了用户特征表示，我们就可以基于用户特征为用户推荐与他特征匹配的标的物。构建用户特征的方法主要有如下5种：</p>
<ul>
<li>用户行为记录作为显示特征</li>
</ul>
<p>记录用户过去一段时间对标的物的偏好。拿视频行业来说，如果用户过去一段时间看了A、B、C三个视频，同时可以根据每个视频用户观看时长占视频总时长的比例给用户的行为打分(<script type="math/tex">S_1</script>,<script type="math/tex">S_2</script>,<script type="math/tex">S_3</script>)，这时用户的兴趣偏好就可以记录为：</p>
<script type="math/tex; mode=display">
{(A,S_1),(B,S_2),(C,S_3)}</script><p>该方案直接将用户历史操作过的标的物作为用户的特征表示，在推荐时可以将与用户操作过的标的物相似的标的物推荐给用户。</p>
<ul>
<li>显式的标签特征</li>
</ul>
<p>如果标的物是有标签来描述的，那么这些标签可以用来表征标的物。用户的兴趣画像也可以基于用户对标的物的行为来打上对应的标签。拿视频推荐来举例，如果用户过去看了科幻和恐怖两类电影，那么恐怖、科幻就是用户的偏好标签了。</p>
<p>每个标的物的标签可以是包含权重的，而用户对标的物的操作行为也是有权重的，从而用户的兴趣标签是有权重的。</p>
<p>在具体推荐时，可以将用户的兴趣标签关联到的标的物(具备该标签的标的物)推荐给用户。</p>
<ul>
<li>向量式的兴趣特征</li>
</ul>
<p>可以基于标的物的信息将标的物嵌入到向量空间中，利用向量来表示标的物，我们会在后面讲解嵌入的算法实现方案。有了标的物的向量化表示，用户的兴趣向量就可以用他操作过的标的物的向量的平均向量来表示了。</p>
<p>这里表示用户兴趣向量有很多种策略，可以基于用户对操作过的标的物的评分以及时间加权来获取用户的加权偏好向量，而不是直接取平均。另外，我们也可以根据用户操作过的标的物之间的相似度，为用户构建多个兴趣向量(比如对标的物聚类，用户在某一类上操作过的标的物的向量均值作为用户在这个类别上的兴趣向量)，从而更好地表达用户多方位的兴趣偏好。</p>
<p>有了用户的兴趣向量及标的物的兴趣向量，可以基于向量相似性计算用户对标的物的偏好度，再基于偏好度大小来为用户推荐标的物。</p>
<ul>
<li>通过交互方式获取用户兴趣标签</li>
</ul>
<p>很多APP在用户第一次注册时让用户选择自己的兴趣标签，一旦用户勾选了自己的兴趣标签，那么这些兴趣标签就是系统为用户提供推荐的原材料。具体推荐策略与上面一样。</p>
<ul>
<li>用户的人口统计学特征</li>
</ul>
<p>用户在登陆、注册时提供的关于自身相关的信息、通过运营活动用户填写的信息、通过用户行为利用算法推断得出的结论，如年龄、性别、地域、收入、爱好、居住地、工作地点等是非常重要的信息。基于这些关于用户维度的信息，我们可以将用户特征用向量化表示出来，向量的维度就是可获取的用户特征数。</p>
<p>有了用户特征向量就可以计算用户相似度，将相似用户喜欢的标的物推荐给该用户。</p>
<h2 id="基于标的物信息构建标的物特征表示"><a href="#基于标的物信息构建标的物特征表示" class="headerlink" title="基于标的物信息构建标的物特征表示"></a>基于标的物信息构建标的物特征表示</h2><p>标的物的特征，一般可以利用显式的标签来表示，也可以利用隐式的向量(当然one-hot编码也是向量表示，但是不是隐式的)来刻画，向量的每个维度就是一个隐式的特征项。前面提到某些推荐算法需要计算标的物之间的相似度，下面我们在讲标的物的各种特征表示时，也简单介绍一下标的物之间的相似度计算方法。顺便说一下，标的物关联标的物的推荐范式也需要知道标的物之间的相似度。下面我们从4个方面来详细讲解怎么构建标的物的特征表示。</p>
<ul>
<li>标的物包含标签信息</li>
</ul>
<p>最简单的方式是将将标签按照某种序排列，每个标签看成一个维度，那么每个标的物就可以表示成一个N维的向量了(N是标签的个数)，如果标的物包含某个标签，向量在相应标签的分量上的值为1，否则为0，即所谓的one-hot编码。有可能N非常大(如视频行业，N可能是几万、甚至几十万上百万)，这时向量是稀疏向量(一般标的物只有少量的几个或者几十个标签)，我们可以采用稀疏向量的表示来优化向量存储和计算，提升效率。有了标的物基于标签的向量化表示，很容易基于cosine余弦计算相似度了。</p>
<p>实际上标签不是这么简单的，有很多业务标签是分级的，比如电商(如淘宝)，有多级的标签(见下面图3)，标签的层级关系形成一颗树状结构，这时该怎么向量化呢？最简单的方案是只考虑叶子节点的标签(也是最低层级的标签)，基于叶子节点标签构建向量表示。更复杂的方法，可以基于层级结构构建标签表示及计算标的物相似度。</p>
<p>标签可以是通过算法获取的，比如通过NLP技术从文本信息中提取关键词作为标签。对于图片/视频，它们的描述信息(标题等)可以提取标签，另外可以通过目标检测的方法从图片/视频中提取相关对象构建标签。</p>
<p>标签可以是用户打的，很多产品在用户与标的物交互时可以为标的物打标签，这些标签就是标的物的一种刻画。标签也可是人工标注的，像Netflix在做推荐时，请了上万个专家对视频从上千个维度来打标签，让标签具备非常高的质量。基于这么精细优质的标签做推荐，效果一定不错。很多行业的标的物来源于第三方提供商，他们在入驻平台时会被要求按照某些规范填写相关标签信息(比如典型的如电商)。</p>
<ul>
<li>标的物具备结构化的信息</li>
</ul>
<p>有些行业标的物是具备结构化信息的，如视频行业，一般会有媒资库，媒资库中针对每个节目会有标题、演职员、导演、标签、评分、地域等维度数据，这类数据一般存在关系型数据库中。这类数据，我们可以将一个字段(也是一个特征)作为向量的一个维度，这时向量化表示每个维度的值不一定是数值，但是形式还是向量化的形式，即所谓的向量空间模型（Vector Space Model，简称VSM）。这时我们可以通过如下的方式计算两个标的物之间的相似度。</p>
<script type="math/tex; mode=display">
V_1 = (p_1, p_2, p_3, ..., p_k)</script><script type="math/tex; mode=display">
V_2 = (q_1, q_2, q_3, ..., q_k)</script><script type="math/tex; mode=display">
sim(V_1, V_2) = \sum_{t=1}^{k}w_t*sim(p_t, q_t)</script><ul>
<li>包含文本信息的标的物的特征表示</li>
</ul>
<p>像今日头条和手机百度APP这类新闻资讯或者搜索类APP，标的物就是一篇篇的文章(其中会包含图片或者视频)，文本信息是最重要的信息形式，构建标的物之间的相似性有很多种方法。下面对常用的方法做一些讲解说明。</p>
<p>z. 词袋模型</p>
<p>统计所有文档中词出现的频次转化为向量。</p>
<p>词袋随新词不断增大，矩阵非常稀疏，未保留句法。</p>
<p>a. 利用TF-IDF将文本信息转化为特征向量</p>
<p>TF-IDF通过将所有文档(即标的物)分词，获得所有不同词的集合(假设有M个词)，那么就可以为每个文档构建一个M维(每个词就是一个维度)的向量，而该向量中某个词所在维度的值可以通过统计每个词在文档中的重要性来衡量，这个重要性的度量就是TF-IDF。<br>TF即某个词在某篇文档中出现的频次，用于衡量这个词在文档中的重要性，出现次数越多的词重要性越大，当然我们会提前将“的”、“地”、“啊”等停用词去掉，这些词对构建向量是没有任何实际价值的，甚至是有害的。<script type="math/tex">t_k</script>是第k个词，<script type="math/tex">d_j</script>是第j个文档。</p>
<script type="math/tex; mode=display">
TF(t_k, d_j) = \frac{|| t_k \in d_j  ||}{|| d_j ||}</script><p>IDF代表的是某个词在所有文档中的“区分度”，如果某个词只在少量几个文档中出现，那么它包含的价值就是巨大的(所谓物以稀为贵)，如果某个词在很多文档中出现，那么它就不能很好地衡量(区分出)这个文档。N是所有文档的个数，<script type="math/tex">n_k</script>是包含<script type="math/tex">t_k</script>的文档个数。</p>
<script type="math/tex; mode=display">
IDF(t_k) = log\frac{N}{n_k}</script><script type="math/tex; mode=display">
TF-IDF(t_k, d_j) = TF(t_k, d_j) * IDF(t_k)</script><p>有了基于TF-IDF计算的标的物的向量表示，我们就很容易计算两个标的物之间的相似度了(cosine余弦相似度)。</p>
<p>b. 利用LDA算法构建文章(标的物)的主题</p>
<p>LDA算法是一类文档主题生成模型，包含词、主题、文档三层结构，是一个三层的贝叶斯概率模型。 对于语料库中的每篇文档，LDA定义了如下生成过程（generative process）：</p>
<p>[1] 对每一篇文档，从主题分布中抽取一个主题；<br>[2] 从上述被抽到的主题所对应的单词分布中抽取一个单词；<br>[3] 重复上述过程直至遍历文档中的每一个单词。</p>
<p>我们通过对所有文档进行LDA训练，就可以构建每篇文档的主题分布，从而构建一个基于主题的向量(每个主题就是向量的一个分量，而值就是该主题的概率值)，这样我们就可以利用该向量来计算两篇文档的相似度了。主题模型可以理解为一个降维过程，将文档的词向量表示降维成主题的向量表示(主题的个数是远远小于词的个数的，所以是降维)。</p>
<p>c. 利用doc2vec算法构建文本相似度</p>
<p>doc2vec或者叫做 paragraph2vec, sentence embeddings，是一种非监督式算法，可以获得 句子、段落、文章的稠密向量表达，它是 word2vec 的拓展，2014年被Google的两位大牛提出，并大量用于文本分类和情感分析中。通过doc2vec学出句子、段落、文章的向量表示，可以通过计算向量之间距离来表达句子、段落、文章之间的相似性。</p>
<p>这里我们简单描述一下doc2vec的核心思想。doc2vec受word2vec启发，由它推广而来，我们先来简单解释一下word2vec的思路。</p>
<p>word2vec<a href="#refer-21"><sup>21</sup></a> <a href="#refer-22"><sup>22</sup></a>通过学习一个唯一的向量表示每个词，每个词向量作为矩阵W中的一列(W是所有词的词向量构成的矩阵)，矩阵列可以通过词汇表为每个词做索引，排在索引第一位的放到矩阵W的第一列，如此类推。将学习问题转化为通过上下文词序列中前几个词来预测下一个词。<br>word2vec可以用CBOW, Skipgram训练模型。Skipgram主要通过输入句子中特定的单词来预测该单词周边的其他单词。CBOW是通过目标单词周边的单词来预测目标单词，这点刚好跟skip-gram模型相反。Python包Gensim<a href="#refer-23"><sup>23</sup></a>可用来训练Word2Vec/Doc2Vec。</p>
<p>doc2vec类似地，每个段落/文档表示为向量，作为矩阵D的一列，每个词也表示为一个向量，作为矩阵W中的一列。将学习问题转化为通过上下文词序列中前几个词和段落/文档来预测下一个词。将段落/文档和词向量通过拼接或者平均来预测句子的下一个词(下图是通过“the”、“cat”、“sat”及段落id来预测下一个词“on”)。在训练的时候我们固定上下文的长度，用滑动窗口的方法产生训练集。段落向量/句向量在上下文中共享。</p>
<ul>
<li>图片、音频、视频</li>
</ul>
<p>如果标的物包含的是图片、音频或者视频信息，处理起来会更加复杂。一种方法是利用它们的文本信息(标题、评论、描述信息、利用图像技术提取的字幕等文本信息等等，对于音频，可以通过语音识别转化为文本)采用上面(3)的技术方案获得向量化表示。对于图像或者视频，也可以利用openCV中的PSNR和SSIM算法来表示视频特征，也可以计算视频之间的相似度。另外一种可行的方法是采用图像、音频处理技术直接从图像、视频、音频中提取特征进行向量化表示，从而容易计算出相似度。总之，图片、图像、音频都可以转化为NLP问题或者图像处理问题(见下面图6)，通过图像处理和NLP获得对应的特征表示，从而最终计算出相似度，这里不详细讲解。</p>
<h2 id="基于用户及标的物特征表示为用户推荐标的物"><a href="#基于用户及标的物特征表示为用户推荐标的物" class="headerlink" title="基于用户及标的物特征表示为用户推荐标的物"></a>基于用户及标的物特征表示为用户推荐标的物</h2><ul>
<li>采用跟基于物品的协同过滤类似的方式推荐</li>
</ul>
<p>该方法采用基于用户行为记录的显式特征表示用户特征，通过将用户操作过的标的物最相似的标的物推荐给用户，算法原理跟基于物品的协同过滤类似，计算公式甚至是一样的，但是这里计算标的物相似度是基于标的物的自身信息来计算的，而基于物品的协同过滤是基于用户对标的物的行为矩阵来计算的。</p>
<p>用户<script type="math/tex">u</script>对标的物<script type="math/tex">s</script>的喜好度<script type="math/tex">sim(u,s)</script>，可以表示为：</p>
<script type="math/tex; mode=display">
sim(u, s) = \sum_{s_i\inS} score(u, s_i) * sim(s_i, s)</script><p>其中<script type="math/tex">S</script>是所有用户操作过的标的物的列表，<script type="math/tex">score(u, s_i)</script>是用户<script type="math/tex">u</script>对标的物<script type="math/tex">s_i</script>的喜好度，<script type="math/tex">sim(s_i, s)</script>是标的物<script type="math/tex">s_i</script>和<script type="math/tex">s</script>的相似度。有了用户对每个标的物的相似度，基于相似度降序排列，就可以取topN推荐给用户了。</p>
<p>除了采用上面的公式外，我们在推荐时也可以稍作变化，采用最近邻方法(K-Nearest Neighbor, KNN)。对于用户操作/喜欢过的每个标的物，通过kNN找到最相似的k个标的物。</p>
<ul>
<li>采用跟基于用户协同过滤类似的方法计算推荐</li>
</ul>
<p>如果我们获得了用户的人口统计学向量表示或者基于用户历史操作行为获得了用户的向量化表示，那么我们可以采用跟基于用户的协同过滤方法相似的方法来为用户提供个性化推荐，具体思路如下：</p>
<p>我们可以将与该用户最相似的用户喜欢的标的物推荐给该用户，算法原理跟基于用户的协同过滤类似，计算公式甚至是一样的。但是这里计算用户相似度是基于用户的人口统计学特征向量表示来计算的(计算用户向量cosine余弦相似度)或者是基于用户历史行为嵌入获得的特征向量来计算的，而基于用户的协同过滤是基于用户对标的物的行为矩阵来计算用户之间的相似度。</p>
<p>用户<script type="math/tex">u</script>对标的物<script type="math/tex">s</script>的喜好度<script type="math/tex">sim(u,s)</script>，可以表示为：</p>
<script type="math/tex; mode=display">
sim(u, s) = \sum_{s_i\inU} sim(u, u_i) * score(u_i, s)</script><p>其中<script type="math/tex">U</script>是与该用户最相似的用户集合，<script type="math/tex">score(u_i, s)</script>是用户<script type="math/tex">u</script>对标的物<script type="math/tex">s</script>的喜好度，<script type="math/tex">sim(u_i, u)</script>是标的物<script type="math/tex">u_i</script>和<script type="math/tex">u</script>的相似度。有了用户对每个标的物的相似度，基于相似度降序排列，就可以取topN推荐给用户了。</p>
<p>与前面一样我们也可以采用最近邻方法(K-Nearest Neighbor, KNN)。通过kNN找到最相似的k个用户，将这些用户操作/喜欢过的每个标的物推荐给用户。</p>
<ul>
<li>基于标的物聚类的推荐</li>
</ul>
<p>有了标的物的向量表示，我们可以用kmeans等聚类算法将标的物聚类，有了标的物的聚类，推荐就好办了。从用户历史行为中的标的物所在的类别挑选用户没有操作行为的标的物推荐给用户，这种推荐方式是非常直观自然的。</p>
<ul>
<li>基于向量相似的推荐</li>
</ul>
<p>不管是前面提到的用户的显示的兴趣特征(利用标签来衡量用户兴趣)或者是向量式的兴趣特征(将用户的兴趣投影到向量空间)，我们都可以获得用户兴趣的向量表示。</p>
<p>如果我们获得了用户的向量表示和标的物的向量表示，那么我们就可以通过向量的cosine余弦相似度计算用户与标的物之间的相似度。一样地，有了用户对每个标的物的相似度，基于相似度降序排列，就可以取topN推荐给用户了。</p>
<p>基于向量的相似的推荐，需要计算用户向量与每个标的物向量的相似性。如果标的物数量较多，整个计算过程还是相当耗时的。同样地，计算标的物最相似的K个标的物，也会涉及到与每个其他的标的物计算相似度，也是非常耗时的。</p>
<p>整个计算过程的时间复杂度是<script type="math/tex">O(N^2)</script>，N是标的物的总数。</p>
<p>上述复杂的计算过程可以利用Spark等分布式计算平台来加速计算。对于T+1级(每天更新一次推荐结果)的推荐服务，利用Spark事先计算好，将推荐结果存储起来供前端业务调用是可以的。</p>
<p>另外一种可行的策略是利用高效的向量检索库，在极短时间(一般几毫秒或者几十毫秒)内为用户索引出topN最相似的标的物。目前FaceBook开源的FAISS库(<a href="https://github.com/facebookresearch/faiss)就是一个高效的向量搜索与聚类库，可以在毫秒级响应查询及聚类需求，因此可以用于个性化的实时推荐。目前国内有很多公司将该库用到了推荐业务上。" target="_blank" rel="noopener">https://github.com/facebookresearch/faiss)就是一个高效的向量搜索与聚类库，可以在毫秒级响应查询及聚类需求，因此可以用于个性化的实时推荐。目前国内有很多公司将该库用到了推荐业务上。</a></p>
<p>FAISS库适合稠密向量的检索和聚类，所以对于利用LDA、Doc2vector算法构建向量表示的方案是实用的，因为这些方法构建的是稠密向量。而对于TF-IDF及基于标签构建的向量化表示，就不适用了，这两类方法构建的都是稀疏的高维向量。</p>
<ul>
<li>基于标签的反向倒排索引做推荐</li>
</ul>
<p>基于标的物的标签和用户的历史兴趣，我们可以构建出用户基于标签兴趣的画像及标签与标的物的倒排索引查询表(熟悉搜索的同学应该不难理解)。基于该反向索引表及用户的兴趣画像，我们就可以为用户做个性化推荐了。该类算法其实就是基于标签的召回算法。</p>
<p>具体推荐过程是这样的：从用户画像中获取用户的兴趣标签，基于用户的兴趣标签从倒排索引表中获取该标签对应的标的物，这样就可以从用户关联到标的物了。其中用户的每个兴趣标签及标签关联到的标的物都是有权重的。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>基于内容的推荐是最古老的一类推荐算法，在整个推荐系统发展史上具有举足轻重的地位。虽然它的效果可能没有协同过滤及新一代推荐算法好，但是它们还是非常有应用价值的，甚至是必不可少的。基于内容的推荐算法主要用在如下几类场景。</p>
<ul>
<li>完全个性化推荐</li>
</ul>
<p>就是基于内容特征来为每个用户生成不同的推荐结果，我们常说的推荐系统就是指这类推荐形态。上面一节已经完整地讲解了怎么为用户做个性化推荐，这里不再赘述。</p>
<ul>
<li>的物关联标的物推荐</li>
</ul>
<p>标的物关联标的物的推荐也是工业界最常用的推荐形态，大量用于真实产品中。</p>
<p>上一节讲了很多怎么构建标的物之间相似度的方法，其实这些方法可以直接用来做标的物关联标的物的推荐，只要我们将与某个标的物最相似的topN的标的物作为关联推荐即可。</p>
<ul>
<li>配合其他推荐算法</li>
</ul>
<p>由于基于内容的推荐算法在精准度上不如协同过滤等算法，但是可以更好的适应冷启动，所以在实际业务中基于内容的推荐算法会配合其他算法一起服务于用户，最常用的方法是采用级联的方式，先给用户协同过滤的推荐结果，如果该用户行为少没有协同过滤推荐结果，就为该用户推荐基于内容的推荐算法产生的推荐结果。</p>
<ul>
<li>主题推荐</li>
</ul>
<p>如果我们有标的物的标签信息，并且基于标签系统构建了一套推荐算法，那么我们就可以将用户喜欢的标签采用主题的方式推荐给用户，每个主题就是用户的一个兴趣标签。通过一些列主题的罗列展示，让用户从中筛选自己感兴趣的内容(见下面图8)。Netflix的首页大量采用基于主题的推荐模式。主题推荐的好处是可以将用户所有的兴趣点按照兴趣偏好大小先后展示出来，可解释性强，并且让用户有更多维度的自由选择空间。</p>
<ul>
<li>给用户推荐标签</li>
</ul>
<p>另外一种可行的推荐策略是不直接给用户推荐标的物，而是给用户推荐标签，用户通过关注推荐的标签，自动获取具备该标签的标的物。除了可以通过推荐的标签关联到标的物获得直接推荐标的物类似的效果外，间接地通过用户对推荐的标签的选择、关注进一步获得了用户的兴趣偏好，这是一种可行的推荐产品实现方案。</p>
<h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>基于内容的推荐算法算是一类比较直观易懂的算法，目前在工业级推荐系统中有大量的使用场景，在本节我们对基于内容的推荐算法的优缺点加以说明，方便读者在实践中选择取舍，构建适合业务场景的内容推荐系统。</p>
<p>优点：</p>
<p>基于上面的介绍，基于内容的推荐算法是非常直观的，具体来说，它有如下6个优点。</p>
<p>（1）可以很好的识别用户的口味<br>该算法完全基于用户的历史兴趣来为用户推荐，推荐的标的物也是跟用户历史兴趣相似的，所以推荐的内容一定是符合用户的口味的。</p>
<p>（2）非常直观易懂，可解释性强<br>基于内容的推荐算法基于用户的兴趣为用户推荐跟他兴趣相似的标的物，原理简单，容易理解。同时，由于是基于用户历史兴趣推荐跟兴趣相似的标的物，用户也非常容易接受和认可。</p>
<p>（3）可以更加容易的解决冷启动<br>只要用户有一个操作行为，就可以基于内容为用户做推荐，不依赖其他用户行为。同时对于新入库的标的物，只要它具备metadata信息等标的物相关信息，就可以利用基于内容的推荐算法将它分发出去。因此，对于强依赖于UGC内容的产品(如抖音、快手等)，基于内容的推荐可以更好地对标的物提供方进行流量扶持。</p>
<p>（4）算法实现相对简单<br>基于内容的推荐可以基于标签维度做推荐，也可以将标的物嵌入向量空间中，利用相似度做推荐，不管哪种方式，算法实现较简单，有现成的开源的算法库供开发者使用，非常容易落地到真实的业务场景中。</p>
<p>（5）对于小众领域也能有比较好的推荐效果<br>对于冷门小众的标的物，用户行为少，协同过滤等方法很难将这类内容分发出去，而基于内容的算法受到这种情况的影响相对较小。</p>
<p>（6）非常适合标的物快速增长的有时效性要求的产品<br>对于标的物增长很快的产品，如今日头条等新闻资讯类APP，基本每天都有几十万甚至更多的标的物入库，另外标的物时效性也很强。新标的物一般用户行为少，协同过滤等算法很难将这些大量实时产生的新标的物推荐出去，这时就可以采用基于内容的推荐算法更好地分发这些内容。</p>
<p>缺点：</p>
<p>虽然基于内容的推荐实现相对容易，解释性强，但是基于内容的推荐算法存在一些不足，导致它的效果及应用范围受到一定限制。主要的问题有如下4个：</p>
<p>（1）推荐范围狭窄，新颖性不强<br>由于该类算法只依赖于单个用户的行为为用户做推荐，推荐的结果会聚集在用户过去感兴趣的标的物类别上，如果用户不主动关注其他类型的标的物，很难为用户推荐多样性的结果，也无法挖掘用户深层次的潜在兴趣。特别是对于新用户，只有少量的行为，为用户推荐的标的物较单一。</p>
<p>（2）需要知道相关的内容信息且处理起来较难<br>内容信息主要是文本、视频、音频，处理起来费力，相对难度较大，依赖领域知识。同时这些信息更容易有更大概率含有噪音，增加了处理难度。另外，对内容理解的全面性、完整性及准确性会影响推荐的效果。</p>
<p>（3）较难将长尾标的物分发出去<br>基于内容的推荐需要用户对标的物有操作行为，长尾标的物一般操作行为非常少，只有很少用户操作，甚至没有用户操作。由于基于内容的推荐只利用单个用户行为做推荐，所以更难将它分发给更多的用户。</p>
<p>（4）推荐精准度不太高<br>基于工业界的实践经验，相比协同过滤算法，基于内容的推荐算法精准度要差一些。</p>
<h1 id="落地"><a href="#落地" class="headerlink" title="落地"></a>落地</h1><p>基于内容的推荐算法虽然容易理解，实现起来相对简单，但在落地到真实业务场景中，有很多问题需要思考解决。下面这些问题是在落地基于内容推荐算法时必须思考的，这里将他们列举出来，并提供一些简单的建议，希望可以帮到读者。</p>
<ul>
<li>内容来源的获取</li>
</ul>
<p>对于基于内容的推荐来说，有完整的、高质量的内容信息是可以构建精准的推荐算法的基础，那我们有哪些方法可以获取内容来源呢？下面这些策略是主要获取内容(包括标的物内容和用户相关内容)来源的手段。</p>
<p>（1）标的物“自身携带”的信息<br>标的物在上架时，第三方会准备相关的内容信息，如天猫上的商品在上架时会补充很多必要的信息。对于视频来说，各类metadata信息也是视频入库时需要填充的信息。我们要做的是增加对新标的物入库的监控和审核，及时发现信息不全的情况并做适当处理。</p>
<p>（2）通过爬虫获取标的物相关信息<br>通过爬虫爬取的信息可以作为标的物信息的补充，特别是补充上面（1）不全的信息。有了更完整的信息就可以获得更好的特征表示。</p>
<p>（3）通过人工标注数据<br>往往人工标注的数据价值密度高，通过人工精准的标注可以大大提升算法推荐的精准度。但是人工标注成本太大。</p>
<p>（4）通过运营活动或者产品交互让用户填的内容<br>通过抽奖活动让用户填写家庭组成、兴趣偏好等，在用户开始注册时让用户填写兴趣偏好特征，这些都是获取内容的手段。</p>
<p>（5）通过收集用户行为直接获得或者预测推断出的内容<br>通过请求用户GPS位置知道用户的活动轨迹，用户购物时填写收货地址，用户绑定的身份证和银行卡等，通过用户操作行为预测出用户的兴趣偏好，这些方法都可以获得部分用户数据。</p>
<p>（6）通过与第三方合作或者产品矩阵之间补充信息<br>目前中国有大数据交易市场，通过正规的数据交易或者跟其他公司合作，在不侵犯用户隐私的情况下，通过交换数据可以有效填补自己产品上缺失的数据。</p>
<p>如果公司有多个产品，新产品可以借助老产品的巨大用户基数，将新产品的用户与老产品用户关联起来(id-maping或者账号打通)，这样老产品上丰富的用户行为信息可以赋能给新产品。</p>
<ul>
<li>怎么利用负反馈</li>
</ul>
<p>用户对标的物的操作行为不一定代表正向反馈，有可能是负向的。比如点开一个视频，看了不到几秒就退出来了，明显表明用户不喜欢。有很多产品会在用户交互中直接提供负向反馈能力，这样可以收集到更多负向反馈。</p>
<p>负向反馈代表用户强烈的不满，因此如果推荐算法可以很好的利用这些负向反馈就能够大大提升推荐系统的精准度和满意度。基于内容的推荐算法整合负向反馈的方式有如下几种：</p>
<p>(1) 将负向反馈整合到算法模型中<br>在构建算法模型中整合负向反馈，跟正向反馈一起学习，从而更自然地整合负向反馈信息。</p>
<p>(2) 采用事后过滤的方式<br>先给用户生成推荐列表，再从该推荐列表中过滤掉与负向反馈关联的或者相似的标的物。</p>
<p>(3) 采用事前处理的方式<br>从待推荐的候选集中先将与负向反馈相关联或者相似的标的物剔除掉，然后再进行相关算法的推荐。</p>
<ul>
<li>兴趣随时间变化</li>
</ul>
<p>用户的兴趣不是一成不变的，一般用户的兴趣是随着时间变化的，那怎么在算法中整合用户的兴趣变化呢？可行的策略是对用户的兴趣根据时间衰减，最近的行为给予最大的权重。还可以分别给用户建立短期兴趣特征和长期兴趣特征，在推荐时既考虑短期兴趣又考虑长期兴趣，最终推荐列表中整合两部分的推荐结果。</p>
<p>对于新闻资讯等这类时效性强的产品，能够整合用户的实时兴趣变化可以大大提升用户体验，这也是现在信息流类推荐产品大行其道的原因。</p>
<ul>
<li>数据清洗</li>
</ul>
<p>基于内容的推荐算法依赖于标的物相关的描述信息，这些信息更多的是以文本的形式存在，这就涉及到自然语言处理了，文本中可能会存在很多歧义、符号、脏数据，我们需要事先对数据进行很好的处理，才能让后续的推荐算法产生好的效果。</p>
<ul>
<li>加速计算与节省资源</li>
</ul>
<p>在实际推荐算法落地时，我们会事先为每个标的物计算N(=50)个最相似的标的物，事先将计算好的标的物存起来，减少时间和空间成本，方便后续更好地做推荐。同时也可以利用各种分布式计算平台和快速查询平台(如Spark、FAISS库等)加速计算过程。另外，算法开发过程中尽量做到模块化，对业务做抽象封装，这可以大大提升开发效率，并且可能会节省很多资源。</p>
<ul>
<li>怎么解决基于内容的推荐越推越窄的问题</li>
</ul>
<p>前面提到基于内容的推荐存在越推越窄的缺点，那怎么避免或者减弱这种影响呢？当然用协同过滤等其他算法是一个有效的方法。另外，我们可以给用户做兴趣探索，为用户推荐兴趣之外的特征关联的标的物，通过用户的反馈来拓展用户兴趣空间，这类方法就是强化学习中的EE方法。如果我们构造了标的物的知识图谱系统，我们就可以通过图谱拓展标的物更远的联系，通过长线的相关性来做推荐，同样可以有效解决越推越窄的问题。</p>
<ul>
<li><p>工程落地技术选型<br>本篇文章主要讲的是基于内容的推荐系统的算法实现原理，具体工程实践时，需要考虑到数据处理、模型训练、分布式计算等技术，当前很多开源方案可以使用，常用的如Spark mllib，scikit-learn，Tensorflow，pytorch，gensim等，这些工具都封装了很多数据处理、特征提取、机器学习算法，我们可以基于第二节的算法思路来落地实现。</p>
</li>
<li><p>业务的安全性<br>除了技术外，在推荐产品落地中还需要考虑推荐的标的物的安全性，避免推荐反动、色情、标题党、低俗内容，这些就需要基于NLP或者CV技术对文本或者视频进行分析过滤。如果是UGC平台型的产品，还需要考虑怎么激励优质内容创作者，让好的内容得到更多的分发机会，同时对产生劣质内容的创作者采取一定的惩罚措施，比如限制发文频率、禁止一段时间的发文权限等。</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-8 - 协同过滤</title>
    <url>/ai/ml-system/recommender/8-collaborative-filter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>协同过滤利用了用户对标的物的行为相似性来推荐。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>协同过滤<a href="#refer-1"><sup>1</sup></a> <a href="#refer-24"><sup>24</sup></a>（Collaborative Filter，CF）主要用于召回，主要分为ItemCF和UserCF。</p>
<p>协同过滤的核心是怎么计算标的物之间的相似度以及用户之间的相似度。我们可以采用非常朴素的思想来计算相似度。我们将用户对标的物的评分(或者隐式反馈，如点击、收藏等)构建如下用户行为矩阵(见下面图2)，矩阵的某个元素代表某个用户对某个标的物的评分(如果是隐式反馈，值为1)，如果某个用户对某个标的物未产生行为，值为0。其中行向量代表某个用户对所有标的物的评分向量，列向量代表所有用户对某个标的物的评分向量。有了行向量和列向量，我们就可以计算用户与用户之间、标的物与标的物之间的相似度了。具体来说，行向量之间的相似度就是用户之间的相似度，列向量之间的相似度就是标的物之间的相似度。</p>
<p>为了避免误解，这里简单解释一下隐式反馈，只要不是用户直接评分的操作行为都算隐式反馈，包括浏览、点击、播放、收藏、评论、点赞、转发等等。有很多隐式反馈是可以间接获得评分的，后面会讲解。如果不间接获得评分，就用0、1表示是否操作过。</p>
<p>在真实业务场景中用户数和标的物数一般都是很大的(用户数可能是百万、千万、亿级，标的物可能是十万、百万、千万级)，而每个用户只会操作过有限个标的物，所以用户行为矩阵是稀疏矩阵。正因为矩阵是稀疏的，会方便我们进行相似度计算及为用户做推荐。</p>
<p>相似度的计算可以采用cosine余弦相似度算法来计算，可以是行或列的相似度：</p>
<script type="math/tex; mode=display">
sim(v_1, v_2) = \frac{v_1 * v_2}{||v_1|| \times ||v_2||}</script><h2 id="基于标的物的协同过滤"><a href="#基于标的物的协同过滤" class="headerlink" title="基于标的物的协同过滤"></a>基于标的物的协同过滤</h2><p>类似地，通过将用户操作过的标的物最相似的标的物推荐给用户，这就是基于标的物的协同过滤的核心思想。</p>
<p>用户u对标的物<script type="math/tex">s</script>的喜好度<script type="math/tex">sim(u,s)</script>可以采用如下公式计算，其中<script type="math/tex">S</script>是所有用户操作过的标的物的列表，<script type="math/tex">score(u, s_i)</script>是用户<script type="math/tex">u</script>对标的物<script type="math/tex">s_i</script>的喜好度，<script type="math/tex">sim(s_i, s)</script>是标的物，<script type="math/tex">s_i</script>与<script type="math/tex">s</script>的相似度。</p>
<script type="math/tex; mode=display">
sim(u, s) = \sum_{s_i \in S} score(u, s_i) * sim(s_i, s)</script><p>实际应用中，采用一个session 内的用户行为来计算 两个商品的pair对。</p>
<p>modified 算法<br>余弦相似度过于粗暴，容易出现哈利波特效应，改良版将会降低热门用户对商品的权重</p>
<ol>
<li>wbcos i2i (weighted bin)</li>
<li>swing i2i</li>
<li>expectaion i2i</li>
</ol>
<p>最小化目标函数算法</p>
<ol>
<li>WALS</li>
<li>SGD</li>
</ol>
<p>SGD优点：非常灵活：适用于其他损失函数；可以并行化。</p>
<p>SGD缺点：较慢，收敛速度不那么快；难以处理未观察到的项（entries），需要使用负采样或gravity。</p>
<p>WALS优点：可以并行化；收敛速度比SGD更快；更容易处理未观察到的项（entries）。</p>
<p>WALS缺点：仅适用于平方损失；</p>
<p>ranki2i<br>背景：上面都是基于统计产生的i2i,实际展示的时候不是要最相似原商品的，还有考虑该商品的ctr 和 cvr 等综合产出<br>过程：利用模型，离线训练和离线预测，右i的点击率，并进行重排。</p>
<ol>
<li>分别预测ctr，cvr<br>类似于线上rank,这里采用左i的feature和右i的feature，模型可采用现有rank模型，（gbdt，lr，dnn皆可）</li>
<li>一步到位<br>利用pairwise或者listwise 作为损失函数<br>将gmv或者点击率转化为预测目标，label为多分类，指标为ndcg.</li>
</ol>
<h2 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h2><p>根据上面算法思想的介绍，我们可以将与该用户最相似的用户喜欢的标的物推荐给该用户。这就是基于用户的协同过滤的核心思想。</p>
<p>用户<script type="math/tex">u</script>对标的物s的喜好度<script type="math/tex">sim(u,s)</script>可以采用如下公式计算，其中<script type="math/tex">U</script>是与该用户最相似的用户集合(我们可以基于用户相似度找到与某用户最相似的K个用户)，<script type="math/tex">score(u_i, s)</script>是用户<script type="math/tex">u_i</script>对标的物s的喜好度(对于隐式反馈为1，而对于非隐式反馈，该值为用户对标的物的评分)，<script type="math/tex">sim(u, u_i)</script>是用户<script type="math/tex">u_i</script>与用户<script type="math/tex">u</script>的相似度。</p>
<script type="math/tex; mode=display">
sim(u, s) = \sum_{u_i \in U} sim(u, u_i) * score(u_i, s)</script><p>有了用户对每个标的物的评分，基于评分降序排列，就可以取topN推荐给用户了。</p>
<h1 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h1><p>虽然协同过滤算法原理非常简单，但是在大规模用户及海量标的物的场景下，单机是难以解决计算问题的，我们必须借助分布式技术来实现，让整个算法可以应对大规模数据的挑战。在本节，我们基于主流的Spark分布式计算平台相关的技术来详细讲解协同过滤算法的离线(批处理)实现思路，供大家参考(读者可以阅读参考文献1、2、3、4了解协同过滤算法原理及工业应用)，同时会在下一节讲解在近实时场景下怎么在工程上实现协同过滤算法。</p>
<p>在这里我们只讲解基于标的物的协同过滤算法的工程实现方案，基于用户的协同过滤思路完全一样，不再赘述。</p>
<p>为了简单起见，我们可以将推荐过程拆解为2个阶段，先计算相似度，再为用户推荐。下面分别介绍这两个步骤怎么工程实现。</p>
<ul>
<li>计算topK相似度</li>
</ul>
<p>本步骤我们计算出任意两个标的物之间的相似度，有了任意两个标的物之间的相似度，那么我们就可以为每个标的物计算出与它最相似的K个标的物了。</p>
<hr>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 4-9 - 矩阵分解</title>
    <url>/ai/ml-system/recommender/9-matrix-factorization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>矩阵分解将用户行为矩阵分解为两个低秩矩阵的乘积，本质上是一种嵌入(Embedding)方法。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>矩阵分解<a href="#refer-2"><sup>2</sup></a>主要使用的是特征分解和奇异值分解（SVD）。</p>
<p>SVD++ BiasSVD</p>
<p>—</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-1 - 产品功能总览</title>
    <url>/ai/ml-system/system/1-overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>机器学习产品的基本功能，现状和趋势。</p>
<a id="more"></a>
<p>机器学习已经被广泛应用于推荐，风控，广告，搜索，图像，语音，文本等各个领域。机器学习系统也成为核心组件之一，用于建模，训练，预测的迭代流程。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>负责数据的存储，清洗，标注，以及特征工程，使用SQL，pandas，scikit等工具分析数据分布，提取特征。</p>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>提供Jupyter Notebook界面，调试训练模型。</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>提供分布式/硬件加速训练和调参功能。</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>提供模型在线服务或批处理功能。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-2 - 数据预处理</title>
    <url>/ai/ml-system/system/2-data-preprocess/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-3 - 实验</title>
    <url>/ai/ml-system/system/3-experiment/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-4 - 训练</title>
    <url>/ai/ml-system/system/4-training/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-4 - 训练</title>
    <url>/ai/ml-system/system/5-automl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-4 - 模型服务</title>
    <url>/ai/ml-system/system/6-serving/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系统 3-7 - Kubeflow</title>
    <url>/ai/ml-system/system/7-kubeflow/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>推理优化</tag>
      </tags>
  </entry>
</search>
